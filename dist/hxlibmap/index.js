// Generated by Haxe 4.3.2
"use strict";
Math.__name__ = true;
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
}
Std.__name__ = true;
class StringBuf {
	constructor() {
		this.b = "";
	}
}
StringBuf.__name__ = true;
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
	}
	unwrap() {
		return this.__nativeException;
	}
	toString() {
		return this.get_message();
	}
	get_message() {
		return this.message;
	}
	get_native() {
		return this.__nativeException;
	}
	static caught(value) {
		if(((value) instanceof haxe_Exception)) {
			return value;
		} else if(((value) instanceof Error)) {
			return new haxe_Exception(value.message,null,value);
		} else {
			return new haxe_ValueException(value,null,value);
		}
	}
	static thrown(value) {
		if(((value) instanceof haxe_Exception)) {
			return value.get_native();
		} else if(((value) instanceof Error)) {
			return value;
		} else {
			let e = new haxe_ValueException(value);
			return e;
		}
	}
}
haxe_Exception.__name__ = true;
class haxe_Log {
	static formatOutput(v,infos) {
		let str = Std.string(v);
		if(infos == null) {
			return str;
		}
		let pstr = infos.fileName + ":" + infos.lineNumber;
		if(infos.customParams != null) {
			let _g = 0;
			let _g1 = infos.customParams;
			while(_g < _g1.length) {
				let v = _g1[_g];
				++_g;
				str += ", " + Std.string(v);
			}
		}
		return pstr + ": " + str;
	}
	static trace(v,infos) {
		let str = haxe_Log.formatOutput(v,infos);
		if(typeof(console) != "undefined" && console.log != null) {
			console.log(str);
		}
	}
}
haxe_Log.__name__ = true;
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
	}
	unwrap() {
		return this.value;
	}
}
haxe_ValueException.__name__ = true;
class haxe_ds_StringMap {
	constructor() {
		this.h = Object.create(null);
	}
}
haxe_ds_StringMap.__name__ = true;
class haxe_exceptions_PosException extends haxe_Exception {
	constructor(message,previous,pos) {
		super(message,previous);
		if(pos == null) {
			this.posInfos = { fileName : "(unknown)", lineNumber : 0, className : "(unknown)", methodName : "(unknown)"};
		} else {
			this.posInfos = pos;
		}
	}
	toString() {
		return "" + super.toString() + " in " + this.posInfos.className + "." + this.posInfos.methodName + " at " + this.posInfos.fileName + ":" + this.posInfos.lineNumber;
	}
}
haxe_exceptions_PosException.__name__ = true;
class haxe_exceptions_NotImplementedException extends haxe_exceptions_PosException {
	constructor(message,previous,pos) {
		if(message == null) {
			message = "Not implemented";
		}
		super(message,previous,pos);
	}
}
haxe_exceptions_NotImplementedException.__name__ = true;
class haxe_io_Eof {
	constructor() {
	}
	toString() {
		return "Eof";
	}
}
haxe_io_Eof.__name__ = true;
class haxe_io_Input {
	readByte() {
		throw new haxe_exceptions_NotImplementedException(null,null,{ fileName : "haxe/io/Input.hx", lineNumber : 53, className : "haxe.io.Input", methodName : "readByte"});
	}
}
haxe_io_Input.__name__ = true;
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe_iterators_ArrayIterator.__name__ = true;
class hxmath_math_IntVector2Default {
	constructor(x,y) {
		this.x = x;
		this.y = y;
	}
	toString() {
		return "(" + this.x + ", " + this.y + ")";
	}
}
hxmath_math_IntVector2Default.__name__ = true;
class hxmath_math_IntVector2 {
	static _new(x,y) {
		return new hxmath_math_IntVector2Default(x,y);
	}
	static fromArray(rawData) {
		if(rawData.length != 2) {
			throw haxe_Exception.thrown("Invalid rawData.");
		}
		return hxmath_math_IntVector2._new(rawData[0],rawData[1]);
	}
	static toVector2(this1) {
		let self = this1;
		return new hxmath_math_Vector2Default(self.x,self.y);
	}
	static dot(a,b) {
		return a.x * b.x + a.y * b.y;
	}
	static multiply(a,s) {
		let self = a;
		let self1 = hxmath_math_IntVector2._new(self.x,self.y);
		self1.x *= s;
		self1.y *= s;
		return self1;
	}
	static add(a,b) {
		let self = a;
		let self1 = hxmath_math_IntVector2._new(self.x,self.y);
		self1.x += b.x;
		self1.y += b.y;
		return self1;
	}
	static subtract(a,b) {
		let self = a;
		let self1 = hxmath_math_IntVector2._new(self.x,self.y);
		self1.x -= b.x;
		self1.y -= b.y;
		return self1;
	}
	static negate(a) {
		return hxmath_math_IntVector2._new(-a.x,-a.y);
	}
	static equals(a,b) {
		if(!(a == null && b == null)) {
			if(a != null && b != null && a.x == b.x) {
				return a.y == b.y;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static max(a,b) {
		let self = a;
		let self1 = hxmath_math_IntVector2._new(self.x,self.y);
		let a1 = self1.x;
		let b1 = b.x;
		self1.x = b1 > a1 ? b1 : a1;
		let a2 = self1.y;
		let b2 = b.y;
		self1.y = b2 > a2 ? b2 : a2;
		return self1;
	}
	static min(a,b) {
		let self = a;
		let self1 = hxmath_math_IntVector2._new(self.x,self.y);
		let a1 = self1.x;
		let b1 = b.x;
		self1.x = b1 < a1 ? b1 : a1;
		let a2 = self1.y;
		let b2 = b.y;
		self1.y = b2 < a2 ? b2 : a2;
		return self1;
	}
	static set(this1,x,y) {
		let self = this1;
		self.x = x;
		self.y = y;
		return self;
	}
	static multiplyWith(this1,s) {
		let self = this1;
		self.x *= s;
		self.y *= s;
		return self;
	}
	static addWith(this1,a) {
		let self = this1;
		self.x += a.x;
		self.y += a.y;
		return self;
	}
	static subtractWith(this1,a) {
		let self = this1;
		self.x -= a.x;
		self.y -= a.y;
		return self;
	}
	static maxWith(this1,a) {
		let self = this1;
		let a1 = self.x;
		let b = a.x;
		self.x = b > a1 ? b : a1;
		let a2 = self.y;
		let b1 = a.y;
		self.y = b1 > a2 ? b1 : a2;
		return self;
	}
	static minWith(this1,a) {
		let self = this1;
		let a1 = self.x;
		let b = a.x;
		self.x = b < a1 ? b : a1;
		let a2 = self.y;
		let b1 = a.y;
		self.y = b1 < a2 ? b1 : a2;
		return self;
	}
	static copyTo(this1,target) {
		let self = this1;
		let self1 = self;
		let value = self1.x;
		let self2 = target;
		self2.x = value;
		let self3 = self;
		let value1 = self3.y;
		let self4 = target;
		self4.y = value1;
	}
	static clone(this1) {
		let self = this1;
		return hxmath_math_IntVector2._new(self.x,self.y);
	}
	static getArrayElement(this1,i) {
		let self = this1;
		switch(i) {
		case 0:
			return self.x;
		case 1:
			return self.y;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static setArrayElement(this1,i,value) {
		let self = this1;
		switch(i) {
		case 0:
			return self.x = value;
		case 1:
			return self.y = value;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static applyNegate(this1) {
		let self = this1;
		self.x = -self.x;
		self.y = -self.y;
		return self;
	}
	static applyScalarFunc(this1,func) {
		let self = this1;
		let self1 = self;
		let value = func(self1.x);
		let self2 = self;
		self2.x = value;
		let self3 = self;
		let value1 = func(self3.y);
		let self4 = self;
		self4.y = value1;
		return self;
	}
	static rotateLeft(this1) {
		let self = this1;
		let newX = -self.y;
		self.y = self.x;
		self.x = newX;
		return self;
	}
	static rotateRight(this1) {
		let self = this1;
		let newX = self.y;
		self.y = -self.x;
		self.x = newX;
		return self;
	}
	static get_zero() {
		return hxmath_math_IntVector2._new(0,0);
	}
	static get_xAxis() {
		return hxmath_math_IntVector2._new(1,0);
	}
	static get_yAxis() {
		return hxmath_math_IntVector2._new(0,1);
	}
	static get_lengthSq(this1) {
		let self = this1;
		return self.x * self.x + self.y * self.y;
	}
	static get_rotatedLeft(this1) {
		let self = this1;
		let self1 = self;
		let self2 = hxmath_math_IntVector2._new(self1.x,self1.y);
		let newX = -self2.y;
		self2.y = self2.x;
		self2.x = newX;
		return self2;
	}
	static get_rotatedRight(this1) {
		let self = this1;
		let self1 = self;
		let self2 = hxmath_math_IntVector2._new(self1.x,self1.y);
		let newX = self2.y;
		self2.y = -self2.x;
		self2.x = newX;
		return self2;
	}
}
class hxmath_math_MathUtil {
	static intMax(a,b) {
		if(b > a) {
			return b;
		} else {
			return a;
		}
	}
	static intMin(a,b) {
		if(b < a) {
			return b;
		} else {
			return a;
		}
	}
	static lerpCyclic(a,b,t,max) {
		if(Math.abs(a - b) > 0.5 * max) {
			if(a < b) {
				a += max;
			} else {
				b += max;
			}
		}
		let x = (1.0 - t) * a + t * b;
		if(x < 0) {
			return max - -x % max;
		} else {
			return x % max;
		}
	}
	static sign(x,w) {
		if(w == null) {
			w = 0;
		}
		if(Math.abs(x) < w) {
			return 0;
		} else if(x <= -w) {
			return -1;
		} else {
			return 1;
		}
	}
	static rangeDistance(aStart,aWidth,bStart,bWidth) {
		if(aStart + aWidth < bStart) {
			return bStart - (aStart + aWidth);
		} else if(bStart + bWidth < aStart) {
			return aStart - (bStart + bWidth);
		} else {
			return 0;
		}
	}
	static openRangeContains(aStart,aWidth,x) {
		if(x > aStart) {
			return x < aStart + aWidth;
		} else {
			return false;
		}
	}
	static openRangesIntersect(aStart,aWidth,bStart,bWidth) {
		return !(aStart >= bStart + bWidth || bStart >= aStart + aWidth);
	}
	static closedRangeContains(aStart,aWidth,x) {
		if(x >= aStart) {
			return x <= aStart + aWidth;
		} else {
			return false;
		}
	}
	static radToDeg(rad) {
		return 180 / Math.PI * rad;
	}
	static degToRad(deg) {
		return Math.PI / 180 * deg;
	}
	static wrap(x,n) {
		if(x < 0) {
			return n - -x % n;
		} else {
			return x % n;
		}
	}
	static clamp(value,min,max) {
		if(value < min) {
			return min;
		} else if(value > max) {
			return max;
		} else {
			return value;
		}
	}
	static orient2d(a,b,c) {
		let result = (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);
		if(result > 0) {
			return 1;
		} else if(result < 0) {
			return -1;
		} else {
			return 0;
		}
	}
	static det2x2(m00,m10,m01,m11) {
		return m00 * m11 - m10 * m01;
	}
	static det3x3(m00,m10,m20,m01,m11,m21,m02,m12,m22) {
		return m00 * (m11 * m22 - m21 * m12) - m10 * (m01 * m22 - m21 * m02) + m20 * (m01 * m12 - m11 * m02);
	}
	static det4x4(m00,m10,m20,m30,m01,m11,m21,m31,m02,m12,m22,m32,m03,m13,m23,m33) {
		return m00 * (m11 * (m22 * m33 - m32 * m23) - m21 * (m12 * m33 - m32 * m13) + m31 * (m12 * m23 - m22 * m13)) - m10 * (m01 * (m22 * m33 - m32 * m23) - m21 * (m02 * m33 - m32 * m03) + m31 * (m02 * m23 - m22 * m03)) + m20 * (m01 * (m12 * m33 - m32 * m13) - m11 * (m02 * m33 - m32 * m03) + m31 * (m02 * m13 - m12 * m03)) - m30 * (m01 * (m12 * m23 - m22 * m13) - m11 * (m02 * m23 - m22 * m03) + m21 * (m02 * m13 - m12 * m03));
	}
}
hxmath_math_MathUtil.__name__ = true;
class hxmath_math_Matrix2x2Default {
	constructor(a,b,c,d) {
		this.a = a;
		this.b = b;
		this.c = c;
		this.d = d;
	}
	toString() {
		return "[a: " + this.a + ", b: " + this.b + ", c: " + this.c + ", d: " + this.d + "]";
	}
}
hxmath_math_Matrix2x2Default.__name__ = true;
class hxmath_math_Matrix2x2 {
	static _new(a,b,c,d) {
		return new hxmath_math_Matrix2x2Default(a,b,c,d);
	}
	static fromArray(rawData) {
		if(rawData.length != 4) {
			throw haxe_Exception.thrown("Invalid rawData.");
		}
		return new hxmath_math_Matrix2x2Default(rawData[0],rawData[1],rawData[2],rawData[3]);
	}
	static fromMatrix2x2Shape(other) {
		return new hxmath_math_Matrix2x2Default(other.a,other.b,other.c,other.d);
	}
	static multiplyScalar(s,m) {
		return new hxmath_math_Matrix2x2Default(s * m.a,s * m.b,s * m.c,s * m.d);
	}
	static multiplyVector(m,v) {
		return new hxmath_math_Vector2Default(m.a * v.x + m.c * v.y,m.b * v.x + m.d * v.y);
	}
	static multiply(m,n) {
		return new hxmath_math_Matrix2x2Default(m.a * n.a + m.c * n.b,m.a * n.c + m.c * n.d,m.b * n.a + m.d * n.b,m.b * n.c + m.d * n.d);
	}
	static add(m,n) {
		let self = m;
		let self1 = new hxmath_math_Matrix2x2Default(self.a,self.b,self.c,self.d);
		self1.a += n.a;
		self1.b += n.b;
		self1.c += n.c;
		self1.d += n.d;
		return self1;
	}
	static subtract(m,n) {
		let self = m;
		let self1 = new hxmath_math_Matrix2x2Default(self.a,self.b,self.c,self.d);
		self1.a -= n.a;
		self1.b -= n.b;
		self1.c -= n.c;
		self1.d -= n.d;
		return self1;
	}
	static negate(m) {
		return new hxmath_math_Matrix2x2Default(-m.a,-m.b,-m.c,-m.d);
	}
	static equals(m,n) {
		if(!(m == null && n == null)) {
			if(m != null && n != null && m.a == n.a && m.b == n.b && m.c == n.c) {
				return m.d == n.d;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static rotate(angle) {
		let self = new hxmath_math_Matrix2x2Default(0.0,0.0,0.0,0.0);
		let s = Math.sin(angle);
		let c = Math.cos(angle);
		self.a = c;
		self.b = s;
		self.c = -s;
		self.d = c;
		return self;
	}
	static scale(sx,sy) {
		return new hxmath_math_Matrix2x2Default(sx,0.0,0.0,sy);
	}
	static setRotate(this1,angle) {
		let self = this1;
		let s = Math.sin(angle);
		let c = Math.cos(angle);
		self.a = c;
		self.b = s;
		self.c = -s;
		self.d = c;
		return self;
	}
	static set(this1,a,b,c,d) {
		let self = this1;
		self.a = a;
		self.b = b;
		self.c = c;
		self.d = d;
		return this1;
	}
	static addWith(this1,m) {
		let self = this1;
		self.a += m.a;
		self.b += m.b;
		self.c += m.c;
		self.d += m.d;
		return self;
	}
	static subtractWith(this1,m) {
		let self = this1;
		self.a -= m.a;
		self.b -= m.b;
		self.c -= m.c;
		self.d -= m.d;
		return self;
	}
	static copyTo(this1,target) {
		let self = this1;
		let self1 = self;
		let value = self1.a;
		let self2 = target;
		self2.a = value;
		let self3 = self;
		let value1 = self3.b;
		let self4 = target;
		self4.b = value1;
		let self5 = self;
		let value2 = self5.c;
		let self6 = target;
		self6.c = value2;
		let self7 = self;
		let value3 = self7.d;
		let self8 = target;
		self8.d = value3;
	}
	static copyToShape(this1,target) {
		let self = this1;
		target.a = self.a;
		target.b = self.b;
		target.c = self.c;
		target.d = self.d;
	}
	static copyFromShape(this1,source) {
		let self = this1;
		self.a = source.a;
		self.b = source.b;
		self.c = source.c;
		self.d = source.d;
	}
	static clone(this1) {
		let self = this1;
		return new hxmath_math_Matrix2x2Default(self.a,self.b,self.c,self.d);
	}
	static getArrayElement(this1,i) {
		let self = this1;
		switch(i) {
		case 0:
			return self.a;
		case 1:
			return self.b;
		case 2:
			return self.c;
		case 3:
			return self.d;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static setArrayElement(this1,i,value) {
		let self = this1;
		switch(i) {
		case 0:
			return self.a = value;
		case 1:
			return self.b = value;
		case 2:
			return self.c = value;
		case 3:
			return self.d = value;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static getElement(this1,column,row) {
		let self = this1;
		let self1 = self;
		switch(row * 2 + column) {
		case 0:
			return self1.a;
		case 1:
			return self1.b;
		case 2:
			return self1.c;
		case 3:
			return self1.d;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static setElement(this1,column,row,value) {
		let self = this1;
		let self1 = self;
		switch(row * 2 + column) {
		case 0:
			return self1.a = value;
		case 1:
			return self1.b = value;
		case 2:
			return self1.c = value;
		case 3:
			return self1.d = value;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static col(this1,index) {
		let self = this1;
		switch(index) {
		case 0:
			return new hxmath_math_Vector2Default(self.a,self.b);
		case 1:
			return new hxmath_math_Vector2Default(self.c,self.d);
		default:
			throw haxe_Exception.thrown("Invalid column");
		}
	}
	static row(this1,index) {
		let self = this1;
		switch(index) {
		case 0:
			return new hxmath_math_Vector2Default(self.a,self.c);
		case 1:
			return new hxmath_math_Vector2Default(self.b,self.d);
		default:
			throw haxe_Exception.thrown("Invalid row");
		}
	}
	static transposeMultiplyVector(this1,v) {
		let self = this1;
		return new hxmath_math_Vector2Default(self.a * v.x + self.b * v.y,self.c * v.x + self.d * v.y);
	}
	static applyScalarFunc(this1,func) {
		let self = this1;
		let self1 = self;
		let value = func(self1.a);
		let self2 = self;
		self2.a = value;
		let self3 = self;
		let value1 = func(self3.b);
		let self4 = self;
		self4.b = value1;
		let self5 = self;
		let value2 = func(self5.c);
		let self6 = self;
		self6.c = value2;
		let self7 = self;
		let value3 = func(self7.d);
		let self8 = self;
		self8.d = value3;
		return self;
	}
	static get_zero() {
		return new hxmath_math_Matrix2x2Default(0.0,0.0,0.0,0.0);
	}
	static get_identity() {
		return new hxmath_math_Matrix2x2Default(1.0,0.0,0.0,1.0);
	}
	static get_det(this1) {
		let self = this1;
		return self.a * self.d - self.c * self.b;
	}
	static get_transpose(this1) {
		let self = this1;
		return new hxmath_math_Matrix2x2Default(self.a,self.c,self.b,self.d);
	}
}
class hxmath_math_Matrix3x2Default {
	constructor(a,b,c,d,tx,ty) {
		this.a = a;
		this.b = b;
		this.c = c;
		this.d = d;
		this.tx = tx;
		this.ty = ty;
	}
	toString() {
		return "[a: " + this.a + ", b: " + this.b + ", c: " + this.c + ", d: " + this.d + ", tx: " + this.tx + ", ty: " + this.ty + "]";
	}
}
hxmath_math_Matrix3x2Default.__name__ = true;
class hxmath_math_Matrix3x2 {
	static _new(a,b,c,d,tx,ty) {
		return new hxmath_math_Matrix3x2Default(a,b,c,d,tx,ty);
	}
	static fromArray(rawData) {
		if(rawData.length != 6) {
			throw haxe_Exception.thrown("Invalid rawData.");
		}
		return new hxmath_math_Matrix3x2Default(rawData[0],rawData[1],rawData[2],rawData[3],rawData[4],rawData[5]);
	}
	static fromMatrix3x2Shape(other) {
		return new hxmath_math_Matrix3x2Default(other.a,other.b,other.c,other.d,other.tx,other.ty);
	}
	static multiplyScalar(s,m) {
		return new hxmath_math_Matrix3x2Default(s * m.a,s * m.b,s * m.c,s * m.d,s * m.tx,s * m.ty);
	}
	static transform(m,v) {
		let self = m;
		let m1 = new hxmath_math_Matrix2x2Default(self.a,self.b,self.c,self.d);
		let this1 = new hxmath_math_Vector2Default(m1.a * v.x + m1.c * v.y,m1.b * v.x + m1.d * v.y);
		let self1 = m;
		let b = new hxmath_math_Vector2Default(self1.tx,self1.ty);
		let self2 = this1;
		let self3 = new hxmath_math_Vector2Default(self2.x,self2.y);
		self3.x += b.x;
		self3.y += b.y;
		return self3;
	}
	static concat(m,n) {
		let self = m;
		let mLinear = new hxmath_math_Matrix2x2Default(self.a,self.b,self.c,self.d);
		let self1 = n;
		let nLinear = new hxmath_math_Matrix2x2Default(self1.a,self1.b,self1.c,self1.d);
		let resultLinear = new hxmath_math_Matrix2x2Default(mLinear.a * nLinear.a + mLinear.c * nLinear.b,mLinear.a * nLinear.c + mLinear.c * nLinear.d,mLinear.b * nLinear.a + mLinear.d * nLinear.b,mLinear.b * nLinear.c + mLinear.d * nLinear.d);
		let v = new hxmath_math_Vector2Default(n.tx,n.ty);
		let this1 = new hxmath_math_Vector2Default(mLinear.a * v.x + mLinear.c * v.y,mLinear.b * v.x + mLinear.d * v.y);
		let b = new hxmath_math_Vector2Default(m.tx,m.ty);
		let self2 = this1;
		let self3 = new hxmath_math_Vector2Default(self2.x,self2.y);
		self3.x += b.x;
		self3.y += b.y;
		let resultAffine = self3;
		return new hxmath_math_Matrix3x2Default(resultLinear.a,resultLinear.b,resultLinear.c,resultLinear.d,resultAffine.x,resultAffine.y);
	}
	static add(m,n) {
		let self = m;
		let self1 = new hxmath_math_Matrix3x2Default(self.a,self.b,self.c,self.d,self.tx,self.ty);
		self1.a += n.a;
		self1.b += n.b;
		self1.c += n.c;
		self1.d += n.d;
		self1.tx += n.tx;
		self1.ty += n.ty;
		return self1;
	}
	static subtract(m,n) {
		let self = m;
		let self1 = new hxmath_math_Matrix3x2Default(self.a,self.b,self.c,self.d,self.tx,self.ty);
		self1.a -= n.a;
		self1.b -= n.b;
		self1.c -= n.c;
		self1.d -= n.d;
		self1.tx -= n.tx;
		self1.ty -= n.ty;
		return self1;
	}
	static negate(m) {
		return new hxmath_math_Matrix3x2Default(-m.a,-m.b,-m.c,-m.d,-m.tx,-m.ty);
	}
	static equals(m,n) {
		if(!(m == null && n == null)) {
			if(m != null && n != null && m.a == n.a && m.b == n.b && m.c == n.c && m.d == n.d && m.tx == n.tx) {
				return m.ty == n.ty;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static rotate(angle) {
		let m = new hxmath_math_Matrix3x2Default(1.0,0.0,0.0,1.0,0.0,0.0);
		let self = new hxmath_math_Matrix2x2Default(0.0,0.0,0.0,0.0);
		let s = Math.sin(angle);
		let c = Math.cos(angle);
		self.a = c;
		self.b = s;
		self.c = -s;
		self.d = c;
		let value = self;
		let self1 = m;
		self1.a = value.a;
		self1.b = value.b;
		self1.c = value.c;
		self1.d = value.d;
		return m;
	}
	static translate(v) {
		let m = new hxmath_math_Matrix3x2Default(1.0,0.0,0.0,1.0,0.0,0.0);
		let self = m;
		self.tx = v.x;
		self.ty = v.y;
		return m;
	}
	static orbit(center,angle) {
		let m = new hxmath_math_Matrix3x2Default(1.0,0.0,0.0,1.0,0.0,0.0);
		let self = new hxmath_math_Matrix2x2Default(0.0,0.0,0.0,0.0);
		let s = Math.sin(angle);
		let c = Math.cos(angle);
		self.a = c;
		self.b = s;
		self.c = -s;
		self.d = c;
		let value = self;
		let self1 = m;
		self1.a = value.a;
		self1.b = value.b;
		self1.c = value.c;
		self1.d = value.d;
		let self2 = m;
		let m1 = new hxmath_math_Matrix2x2Default(self2.a,self2.b,self2.c,self2.d);
		let b = new hxmath_math_Vector2Default(m1.a * center.x + m1.c * center.y,m1.b * center.x + m1.d * center.y);
		let self3 = center;
		let self4 = new hxmath_math_Vector2Default(self3.x,self3.y);
		self4.x -= b.x;
		self4.y -= b.y;
		let t = self4;
		let self5 = m;
		self5.tx = t.x;
		self5.ty = t.y;
		return m;
	}
	static copyTo(this1,target) {
		let self = this1;
		let self1 = self;
		let value = self1.a;
		let self2 = target;
		self2.a = value;
		let self3 = self;
		let value1 = self3.b;
		let self4 = target;
		self4.b = value1;
		let self5 = self;
		let value2 = self5.tx;
		let self6 = target;
		self6.tx = value2;
		let self7 = self;
		let value3 = self7.c;
		let self8 = target;
		self8.c = value3;
		let self9 = self;
		let value4 = self9.d;
		let self10 = target;
		self10.d = value4;
		let self11 = self;
		let value5 = self11.ty;
		let self12 = target;
		self12.ty = value5;
	}
	static copyToShape(this1,target) {
		let self = this1;
		target.a = self.a;
		target.b = self.b;
		target.c = self.c;
		target.d = self.d;
		target.tx = self.tx;
		target.ty = self.ty;
	}
	static copyFromShape(this1,source) {
		let self = this1;
		self.a = source.a;
		self.b = source.b;
		self.c = source.c;
		self.d = source.d;
		self.tx = source.tx;
		self.ty = source.ty;
	}
	static setRotate(this1,angle) {
		let self = this1;
		let s = Math.sin(angle);
		let c = Math.cos(angle);
		self.a = c;
		self.b = s;
		self.c = -s;
		self.d = c;
		return self;
	}
	static setTranslate(this1,x,y) {
		let self = this1;
		self.tx = x;
		self.ty = y;
		return self;
	}
	static set(this1,a,b,c,d,tx,ty) {
		let self = this1;
		self.a = a;
		self.b = b;
		self.c = c;
		self.d = d;
		self.tx = tx;
		self.ty = ty;
		return self;
	}
	static addWith(this1,m) {
		let self = this1;
		self.a += m.a;
		self.b += m.b;
		self.c += m.c;
		self.d += m.d;
		self.tx += m.tx;
		self.ty += m.ty;
		return self;
	}
	static subtractWith(this1,m) {
		let self = this1;
		self.a -= m.a;
		self.b -= m.b;
		self.c -= m.c;
		self.d -= m.d;
		self.tx -= m.tx;
		self.ty -= m.ty;
		return self;
	}
	static clone(this1) {
		let self = this1;
		return new hxmath_math_Matrix3x2Default(self.a,self.b,self.c,self.d,self.tx,self.ty);
	}
	static getArrayElement(this1,i) {
		let self = this1;
		switch(i) {
		case 0:
			return self.a;
		case 1:
			return self.b;
		case 2:
			return self.tx;
		case 3:
			return self.c;
		case 4:
			return self.d;
		case 5:
			return self.ty;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static setArrayElement(this1,i,value) {
		let self = this1;
		switch(i) {
		case 0:
			return self.a = value;
		case 1:
			return self.b = value;
		case 2:
			return self.tx = value;
		case 3:
			return self.c = value;
		case 4:
			return self.d = value;
		case 5:
			return self.ty = value;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static getElement(this1,column,row) {
		let self = this1;
		let self1 = self;
		switch(row * 3 + column) {
		case 0:
			return self1.a;
		case 1:
			return self1.b;
		case 2:
			return self1.tx;
		case 3:
			return self1.c;
		case 4:
			return self1.d;
		case 5:
			return self1.ty;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static setElement(this1,column,row,value) {
		let self = this1;
		let self1 = self;
		switch(row * 3 + column) {
		case 0:
			return self1.a = value;
		case 1:
			return self1.b = value;
		case 2:
			return self1.tx = value;
		case 3:
			return self1.c = value;
		case 4:
			return self1.d = value;
		case 5:
			return self1.ty = value;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static col(this1,index) {
		let self = this1;
		switch(index) {
		case 0:
			return new hxmath_math_Vector2Default(self.a,self.c);
		case 1:
			return new hxmath_math_Vector2Default(self.b,self.d);
		case 2:
			return new hxmath_math_Vector2Default(self.tx,self.ty);
		default:
			throw haxe_Exception.thrown("Invalid column");
		}
	}
	static row(this1,index) {
		let self = this1;
		switch(index) {
		case 0:
			return new hxmath_math_Vector3Default(self.a,self.b,self.tx);
		case 1:
			return new hxmath_math_Vector3Default(self.c,self.d,self.ty);
		default:
			throw haxe_Exception.thrown("Invalid row");
		}
	}
	static applyScalarFunc(this1,func) {
		let self = this1;
		let self1 = self;
		let value = func(self1.a);
		let self2 = self;
		self2.a = value;
		let self3 = self;
		let value1 = func(self3.b);
		let self4 = self;
		self4.b = value1;
		let self5 = self;
		let value2 = func(self5.tx);
		let self6 = self;
		self6.tx = value2;
		let self7 = self;
		let value3 = func(self7.c);
		let self8 = self;
		self8.c = value3;
		let self9 = self;
		let value4 = func(self9.d);
		let self10 = self;
		self10.d = value4;
		let self11 = self;
		let value5 = func(self11.ty);
		let self12 = self;
		self12.ty = value5;
		return self;
	}
	static applySubMatrixTranspose(this1) {
		let self = this1;
		let temp = self.c;
		self.c = self.b;
		self.b = temp;
		return self;
	}
	static applyInvertFrame(this1) {
		let self = this1;
		let self1 = self;
		let temp = self1.c;
		self1.c = self1.b;
		self1.b = temp;
		let tx = -(self.a * self.tx + self.c * self.ty);
		let ty = -(self.b * self.tx + self.d * self.ty);
		self.tx = tx;
		self.ty = ty;
		return self;
	}
	static get_zero() {
		return new hxmath_math_Matrix3x2Default(0.0,0.0,0.0,0.0,0.0,0.0);
	}
	static get_identity() {
		return new hxmath_math_Matrix3x2Default(1.0,0.0,0.0,1.0,0.0,0.0);
	}
	static get_t(this1) {
		let self = this1;
		return new hxmath_math_Vector2Default(self.tx,self.ty);
	}
	static set_t(this1,t) {
		let self = this1;
		self.tx = t.x;
		self.ty = t.y;
		return t;
	}
	static get_linearSubMatrix(this1) {
		let self = this1;
		return new hxmath_math_Matrix2x2Default(self.a,self.b,self.c,self.d);
	}
	static set_linearSubMatrix(this1,value) {
		let self = this1;
		self.a = value.a;
		self.b = value.b;
		self.c = value.c;
		self.d = value.d;
		return value;
	}
}
class hxmath_math_Matrix3x3Default {
	constructor(m00,m10,m20,m01,m11,m21,m02,m12,m22) {
		this.m00 = m00;
		this.m10 = m10;
		this.m20 = m20;
		this.m01 = m01;
		this.m11 = m11;
		this.m21 = m21;
		this.m02 = m02;
		this.m12 = m12;
		this.m22 = m22;
	}
	toString() {
		return "[[" + this.m00 + ", " + this.m10 + ", " + this.m20 + "], [" + this.m01 + ", " + this.m11 + ", " + this.m21 + "], [" + this.m02 + ", " + this.m12 + ", " + this.m22 + "]]";
	}
}
hxmath_math_Matrix3x3Default.__name__ = true;
class hxmath_math_Matrix3x3 {
	static _new(m00,m10,m20,m01,m11,m21,m02,m12,m22) {
		return new hxmath_math_Matrix3x3Default(m00,m10,m20,m01,m11,m21,m02,m12,m22);
	}
	static fromArray(rawData) {
		if(rawData.length != 9) {
			throw haxe_Exception.thrown("Invalid rawData.");
		}
		return new hxmath_math_Matrix3x3Default(rawData[0],rawData[1],rawData[2],rawData[3],rawData[4],rawData[5],rawData[6],rawData[7],rawData[8]);
	}
	static fromMatrix3x3Shape(other) {
		return new hxmath_math_Matrix3x3Default(other.m00,other.m10,other.m20,other.m01,other.m11,other.m21,other.m02,other.m12,other.m22);
	}
	static multiplyScalar(s,a) {
		return new hxmath_math_Matrix3x3Default(s * a.m00,s * a.m10,s * a.m20,s * a.m01,s * a.m11,s * a.m21,s * a.m02,s * a.m12,s * a.m22);
	}
	static multiplyVector(a,v) {
		return new hxmath_math_Vector3Default(a.m00 * v.x + a.m10 * v.y + a.m20 * v.z,a.m01 * v.x + a.m11 * v.y + a.m21 * v.z,a.m02 * v.x + a.m12 * v.y + a.m22 * v.z);
	}
	static multiply(a,b) {
		return new hxmath_math_Matrix3x3Default(a.m00 * b.m00 + a.m10 * b.m01 + a.m20 * b.m02,a.m00 * b.m10 + a.m10 * b.m11 + a.m20 * b.m12,a.m00 * b.m20 + a.m10 * b.m21 + a.m20 * b.m22,a.m01 * b.m00 + a.m11 * b.m01 + a.m21 * b.m02,a.m01 * b.m10 + a.m11 * b.m11 + a.m21 * b.m12,a.m01 * b.m20 + a.m11 * b.m21 + a.m21 * b.m22,a.m02 * b.m00 + a.m12 * b.m01 + a.m22 * b.m02,a.m02 * b.m10 + a.m12 * b.m11 + a.m22 * b.m12,a.m02 * b.m20 + a.m12 * b.m21 + a.m22 * b.m22);
	}
	static add(a,b) {
		let self = a;
		let self1 = new hxmath_math_Matrix3x3Default(self.m00,self.m10,self.m20,self.m01,self.m11,self.m21,self.m02,self.m12,self.m22);
		self1.m00 += b.m00;
		self1.m10 += b.m10;
		self1.m20 += b.m20;
		self1.m01 += b.m01;
		self1.m11 += b.m11;
		self1.m21 += b.m21;
		self1.m02 += b.m02;
		self1.m12 += b.m12;
		self1.m22 += b.m22;
		return self1;
	}
	static subtract(a,b) {
		let self = a;
		let self1 = new hxmath_math_Matrix3x3Default(self.m00,self.m10,self.m20,self.m01,self.m11,self.m21,self.m02,self.m12,self.m22);
		self1.m00 -= b.m00;
		self1.m10 -= b.m10;
		self1.m20 -= b.m20;
		self1.m01 -= b.m01;
		self1.m11 -= b.m11;
		self1.m21 -= b.m21;
		self1.m02 -= b.m02;
		self1.m12 -= b.m12;
		self1.m22 -= b.m22;
		return self1;
	}
	static negate(a) {
		return new hxmath_math_Matrix3x3Default(-a.m00,-a.m10,-a.m20,-a.m01,-a.m11,-a.m21,-a.m02,-a.m12,-a.m22);
	}
	static equals(a,b) {
		if(!(a == null && b == null)) {
			if(a != null && b != null && a.m00 == b.m00 && a.m10 == b.m10 && a.m20 == b.m20 && a.m01 == b.m01 && a.m11 == b.m11 && a.m21 == b.m21 && a.m02 == b.m02 && a.m12 == b.m12) {
				return a.m22 == b.m22;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static rotationX(angleDegrees) {
		let angleRadians = Math.PI / 180 * angleDegrees;
		let s = Math.sin(angleRadians);
		let c = Math.cos(angleRadians);
		return new hxmath_math_Matrix3x3Default(1,0,0,0,c,-s,0,s,c);
	}
	static rotationY(angleDegrees) {
		let angleRadians = Math.PI / 180 * angleDegrees;
		let s = Math.sin(angleRadians);
		let c = Math.cos(angleRadians);
		return new hxmath_math_Matrix3x3Default(c,0,s,0,1,0,-s,0,c);
	}
	static rotationZ(angleDegrees) {
		let angleRadians = Math.PI / 180 * angleDegrees;
		let s = Math.sin(angleRadians);
		let c = Math.cos(angleRadians);
		return new hxmath_math_Matrix3x3Default(c,-s,0,s,c,0,0,0,1);
	}
	static scale(sx,sy,sz) {
		return new hxmath_math_Matrix3x3Default(sx,0.0,0.0,0.0,sy,0.0,0.0,0.0,sz);
	}
	static set(this1,m00,m10,m20,m01,m11,m21,m02,m12,m22) {
		let self = this1;
		self.m00 = m00;
		self.m10 = m10;
		self.m20 = m20;
		self.m01 = m01;
		self.m11 = m11;
		self.m21 = m21;
		self.m02 = m02;
		self.m12 = m12;
		self.m22 = m22;
		return self;
	}
	static addWith(this1,a) {
		let self = this1;
		self.m00 += a.m00;
		self.m10 += a.m10;
		self.m20 += a.m20;
		self.m01 += a.m01;
		self.m11 += a.m11;
		self.m21 += a.m21;
		self.m02 += a.m02;
		self.m12 += a.m12;
		self.m22 += a.m22;
		return self;
	}
	static subtractWith(this1,a) {
		let self = this1;
		self.m00 -= a.m00;
		self.m10 -= a.m10;
		self.m20 -= a.m20;
		self.m01 -= a.m01;
		self.m11 -= a.m11;
		self.m21 -= a.m21;
		self.m02 -= a.m02;
		self.m12 -= a.m12;
		self.m22 -= a.m22;
		return self;
	}
	static copyTo(this1,target) {
		let self = this1;
		let self1 = self;
		let value = self1.m00;
		let self2 = target;
		self2.m00 = value;
		let self3 = self;
		let value1 = self3.m10;
		let self4 = target;
		self4.m10 = value1;
		let self5 = self;
		let value2 = self5.m20;
		let self6 = target;
		self6.m20 = value2;
		let self7 = self;
		let value3 = self7.m01;
		let self8 = target;
		self8.m01 = value3;
		let self9 = self;
		let value4 = self9.m11;
		let self10 = target;
		self10.m11 = value4;
		let self11 = self;
		let value5 = self11.m21;
		let self12 = target;
		self12.m21 = value5;
		let self13 = self;
		let value6 = self13.m02;
		let self14 = target;
		self14.m02 = value6;
		let self15 = self;
		let value7 = self15.m12;
		let self16 = target;
		self16.m12 = value7;
		let self17 = self;
		let value8 = self17.m22;
		let self18 = target;
		self18.m22 = value8;
	}
	static copyToShape(this1,target) {
		let self = this1;
		target.m00 = self.m00;
		target.m01 = self.m01;
		target.m02 = self.m02;
		target.m10 = self.m10;
		target.m11 = self.m11;
		target.m12 = self.m12;
		target.m20 = self.m20;
		target.m21 = self.m21;
		target.m22 = self.m22;
	}
	static copyFromShape(this1,source) {
		let self = this1;
		self.m00 = source.m00;
		self.m01 = source.m01;
		self.m02 = source.m02;
		self.m10 = source.m10;
		self.m11 = source.m11;
		self.m12 = source.m12;
		self.m20 = source.m20;
		self.m21 = source.m21;
		self.m22 = source.m22;
	}
	static clone(this1) {
		let self = this1;
		return new hxmath_math_Matrix3x3Default(self.m00,self.m10,self.m20,self.m01,self.m11,self.m21,self.m02,self.m12,self.m22);
	}
	static getArrayElement(this1,i) {
		let self = this1;
		switch(i) {
		case 0:
			return self.m00;
		case 1:
			return self.m10;
		case 2:
			return self.m20;
		case 3:
			return self.m01;
		case 4:
			return self.m11;
		case 5:
			return self.m21;
		case 6:
			return self.m02;
		case 7:
			return self.m12;
		case 8:
			return self.m22;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static setArrayElement(this1,i,value) {
		let self = this1;
		switch(i) {
		case 0:
			return self.m00 = value;
		case 1:
			return self.m10 = value;
		case 2:
			return self.m20 = value;
		case 3:
			return self.m01 = value;
		case 4:
			return self.m11 = value;
		case 5:
			return self.m21 = value;
		case 6:
			return self.m02 = value;
		case 7:
			return self.m12 = value;
		case 8:
			return self.m22 = value;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static getElement(this1,column,row) {
		let self = this1;
		let self1 = self;
		switch(row * 3 + column) {
		case 0:
			return self1.m00;
		case 1:
			return self1.m10;
		case 2:
			return self1.m20;
		case 3:
			return self1.m01;
		case 4:
			return self1.m11;
		case 5:
			return self1.m21;
		case 6:
			return self1.m02;
		case 7:
			return self1.m12;
		case 8:
			return self1.m22;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static setElement(this1,column,row,value) {
		let self = this1;
		let self1 = self;
		switch(row * 3 + column) {
		case 0:
			return self1.m00 = value;
		case 1:
			return self1.m10 = value;
		case 2:
			return self1.m20 = value;
		case 3:
			return self1.m01 = value;
		case 4:
			return self1.m11 = value;
		case 5:
			return self1.m21 = value;
		case 6:
			return self1.m02 = value;
		case 7:
			return self1.m12 = value;
		case 8:
			return self1.m22 = value;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static col(this1,index) {
		let self = this1;
		switch(index) {
		case 0:
			return new hxmath_math_Vector3Default(self.m00,self.m01,self.m02);
		case 1:
			return new hxmath_math_Vector3Default(self.m10,self.m11,self.m12);
		case 2:
			return new hxmath_math_Vector3Default(self.m20,self.m21,self.m22);
		default:
			throw haxe_Exception.thrown("Invalid column");
		}
	}
	static row(this1,index) {
		let self = this1;
		switch(index) {
		case 0:
			return new hxmath_math_Vector3Default(self.m00,self.m10,self.m20);
		case 1:
			return new hxmath_math_Vector3Default(self.m01,self.m11,self.m21);
		case 2:
			return new hxmath_math_Vector3Default(self.m02,self.m12,self.m22);
		default:
			throw haxe_Exception.thrown("Invalid row");
		}
	}
	static applyScalarFunc(this1,func) {
		let self = this1;
		let self1 = self;
		let value = func(self1.m00);
		let self2 = self;
		self2.m00 = value;
		let self3 = self;
		let value1 = func(self3.m10);
		let self4 = self;
		self4.m10 = value1;
		let self5 = self;
		let value2 = func(self5.m20);
		let self6 = self;
		self6.m20 = value2;
		let self7 = self;
		let value3 = func(self7.m01);
		let self8 = self;
		self8.m01 = value3;
		let self9 = self;
		let value4 = func(self9.m11);
		let self10 = self;
		self10.m11 = value4;
		let self11 = self;
		let value5 = func(self11.m21);
		let self12 = self;
		self12.m21 = value5;
		let self13 = self;
		let value6 = func(self13.m02);
		let self14 = self;
		self14.m02 = value6;
		let self15 = self;
		let value7 = func(self15.m12);
		let self16 = self;
		self16.m12 = value7;
		let self17 = self;
		let value8 = func(self17.m22);
		let self18 = self;
		self18.m22 = value8;
		return self;
	}
	static get_zero() {
		return new hxmath_math_Matrix3x3Default(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	static get_identity() {
		return new hxmath_math_Matrix3x3Default(1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0);
	}
	static get_det(this1) {
		let self = this1;
		let m01 = self.m01;
		let m11 = self.m11;
		let m21 = self.m21;
		let m02 = self.m02;
		let m12 = self.m12;
		let m22 = self.m22;
		return self.m00 * (m11 * m22 - m21 * m12) - self.m10 * (m01 * m22 - m21 * m02) + self.m20 * (m01 * m12 - m11 * m02);
	}
	static get_transpose(this1) {
		let self = this1;
		return new hxmath_math_Matrix3x3Default(self.m00,self.m01,self.m02,self.m10,self.m11,self.m12,self.m20,self.m21,self.m22);
	}
}
class hxmath_math_Matrix4x4Default {
	constructor(m00,m10,m20,m30,m01,m11,m21,m31,m02,m12,m22,m32,m03,m13,m23,m33) {
		this.m00 = m00;
		this.m10 = m10;
		this.m20 = m20;
		this.m30 = m30;
		this.m01 = m01;
		this.m11 = m11;
		this.m21 = m21;
		this.m31 = m31;
		this.m02 = m02;
		this.m12 = m12;
		this.m22 = m22;
		this.m32 = m32;
		this.m03 = m03;
		this.m13 = m13;
		this.m23 = m23;
		this.m33 = m33;
	}
	toString() {
		return "[[" + this.m00 + ", " + this.m10 + ", " + this.m20 + ", " + this.m30 + "], [" + this.m01 + ", " + this.m11 + ", " + this.m21 + ", " + this.m31 + "], [" + this.m02 + ", " + this.m12 + ", " + this.m22 + ", " + this.m32 + "], [" + this.m03 + ", " + this.m13 + ", " + this.m23 + ", " + this.m33 + "]]";
	}
}
hxmath_math_Matrix4x4Default.__name__ = true;
class hxmath_math_Matrix4x4 {
	static _new(m00,m10,m20,m30,m01,m11,m21,m31,m02,m12,m22,m32,m03,m13,m23,m33) {
		return new hxmath_math_Matrix4x4Default(m00,m10,m20,m30,m01,m11,m21,m31,m02,m12,m22,m32,m03,m13,m23,m33);
	}
	static fromArray(rawData) {
		if(rawData.length != 16) {
			throw haxe_Exception.thrown("Invalid rawData.");
		}
		return new hxmath_math_Matrix4x4Default(rawData[0],rawData[1],rawData[2],rawData[3],rawData[4],rawData[5],rawData[6],rawData[7],rawData[8],rawData[9],rawData[10],rawData[11],rawData[12],rawData[13],rawData[14],rawData[15]);
	}
	static fromMatrix4x4Shape(other) {
		return new hxmath_math_Matrix4x4Default(other.m00,other.m10,other.m20,other.m30,other.m01,other.m11,other.m21,other.m31,other.m02,other.m12,other.m22,other.m32,other.m03,other.m13,other.m23,other.m33);
	}
	static multiplyVector(a,v) {
		return new hxmath_math_Vector4Default(a.m00 * v.x + a.m10 * v.y + a.m20 * v.z + a.m30 * v.w,a.m01 * v.x + a.m11 * v.y + a.m21 * v.z + a.m31 * v.w,a.m02 * v.x + a.m12 * v.y + a.m22 * v.z + a.m32 * v.w,a.m03 * v.x + a.m13 * v.y + a.m23 * v.z + a.m33 * v.w);
	}
	static multiply(a,b) {
		return new hxmath_math_Matrix4x4Default(a.m00 * b.m00 + a.m10 * b.m01 + a.m20 * b.m02 + a.m30 * b.m03,a.m00 * b.m10 + a.m10 * b.m11 + a.m20 * b.m12 + a.m30 * b.m13,a.m00 * b.m20 + a.m10 * b.m21 + a.m20 * b.m22 + a.m30 * b.m23,a.m00 * b.m30 + a.m10 * b.m31 + a.m20 * b.m32 + a.m30 * b.m33,a.m01 * b.m00 + a.m11 * b.m01 + a.m21 * b.m02 + a.m31 * b.m03,a.m01 * b.m10 + a.m11 * b.m11 + a.m21 * b.m12 + a.m31 * b.m13,a.m01 * b.m20 + a.m11 * b.m21 + a.m21 * b.m22 + a.m31 * b.m23,a.m01 * b.m30 + a.m11 * b.m31 + a.m21 * b.m32 + a.m31 * b.m33,a.m02 * b.m00 + a.m12 * b.m01 + a.m22 * b.m02 + a.m32 * b.m03,a.m02 * b.m10 + a.m12 * b.m11 + a.m22 * b.m12 + a.m32 * b.m13,a.m02 * b.m20 + a.m12 * b.m21 + a.m22 * b.m22 + a.m32 * b.m23,a.m02 * b.m30 + a.m12 * b.m31 + a.m22 * b.m32 + a.m32 * b.m33,a.m03 * b.m00 + a.m13 * b.m01 + a.m23 * b.m02 + a.m33 * b.m03,a.m03 * b.m10 + a.m13 * b.m11 + a.m23 * b.m12 + a.m33 * b.m13,a.m03 * b.m20 + a.m13 * b.m21 + a.m23 * b.m22 + a.m33 * b.m23,a.m03 * b.m30 + a.m13 * b.m31 + a.m23 * b.m32 + a.m33 * b.m33);
	}
	static add(a,b) {
		let self = a;
		let self1 = new hxmath_math_Matrix4x4Default(self.m00,self.m10,self.m20,self.m30,self.m01,self.m11,self.m21,self.m31,self.m02,self.m12,self.m22,self.m32,self.m03,self.m13,self.m23,self.m33);
		self1.m00 += b.m00;
		self1.m10 += b.m10;
		self1.m20 += b.m20;
		self1.m30 += b.m30;
		self1.m01 += b.m01;
		self1.m11 += b.m11;
		self1.m21 += b.m21;
		self1.m31 += b.m31;
		self1.m02 += b.m02;
		self1.m12 += b.m12;
		self1.m22 += b.m22;
		self1.m32 += b.m32;
		self1.m03 += b.m03;
		self1.m13 += b.m13;
		self1.m23 += b.m23;
		self1.m33 += b.m33;
		return self1;
	}
	static subtract(a,b) {
		let self = a;
		let self1 = new hxmath_math_Matrix4x4Default(self.m00,self.m10,self.m20,self.m30,self.m01,self.m11,self.m21,self.m31,self.m02,self.m12,self.m22,self.m32,self.m03,self.m13,self.m23,self.m33);
		self1.m00 -= b.m00;
		self1.m10 -= b.m10;
		self1.m20 -= b.m20;
		self1.m30 -= b.m30;
		self1.m01 -= b.m01;
		self1.m11 -= b.m11;
		self1.m21 -= b.m21;
		self1.m31 -= b.m31;
		self1.m02 -= b.m02;
		self1.m12 -= b.m12;
		self1.m22 -= b.m22;
		self1.m32 -= b.m32;
		self1.m03 -= b.m03;
		self1.m13 -= b.m13;
		self1.m23 -= b.m23;
		self1.m33 -= b.m33;
		return self1;
	}
	static negate(a) {
		return new hxmath_math_Matrix4x4Default(-a.m00,-a.m10,-a.m20,-a.m30,-a.m01,-a.m11,-a.m21,-a.m31,-a.m02,-a.m12,-a.m22,-a.m32,-a.m03,-a.m13,-a.m23,-a.m33);
	}
	static equals(a,b) {
		if(!(a == null && b == null)) {
			if(a != null && b != null && a.m00 == b.m00 && a.m10 == b.m10 && a.m20 == b.m20 && a.m30 == b.m30 && a.m01 == b.m01 && a.m11 == b.m11 && a.m21 == b.m21 && a.m31 == b.m31 && a.m02 == b.m02 && a.m12 == b.m12 && a.m22 == b.m22 && a.m32 == b.m32 && a.m03 == b.m03 && a.m13 == b.m13 && a.m23 == b.m23) {
				return a.m33 == b.m33;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static set(this1,m00,m10,m20,m30,m01,m11,m21,m31,m02,m12,m22,m32,m03,m13,m23,m33) {
		let self = this1;
		self.m00 = m00;
		self.m10 = m10;
		self.m20 = m20;
		self.m30 = m30;
		self.m01 = m01;
		self.m11 = m11;
		self.m21 = m21;
		self.m31 = m31;
		self.m02 = m02;
		self.m12 = m12;
		self.m22 = m22;
		self.m32 = m32;
		self.m03 = m03;
		self.m13 = m13;
		self.m23 = m23;
		self.m33 = m33;
		return self;
	}
	static addWith(this1,a) {
		let self = this1;
		self.m00 += a.m00;
		self.m10 += a.m10;
		self.m20 += a.m20;
		self.m30 += a.m30;
		self.m01 += a.m01;
		self.m11 += a.m11;
		self.m21 += a.m21;
		self.m31 += a.m31;
		self.m02 += a.m02;
		self.m12 += a.m12;
		self.m22 += a.m22;
		self.m32 += a.m32;
		self.m03 += a.m03;
		self.m13 += a.m13;
		self.m23 += a.m23;
		self.m33 += a.m33;
		return self;
	}
	static subtractWith(this1,a) {
		let self = this1;
		self.m00 -= a.m00;
		self.m10 -= a.m10;
		self.m20 -= a.m20;
		self.m30 -= a.m30;
		self.m01 -= a.m01;
		self.m11 -= a.m11;
		self.m21 -= a.m21;
		self.m31 -= a.m31;
		self.m02 -= a.m02;
		self.m12 -= a.m12;
		self.m22 -= a.m22;
		self.m32 -= a.m32;
		self.m03 -= a.m03;
		self.m13 -= a.m13;
		self.m23 -= a.m23;
		self.m33 -= a.m33;
		return self;
	}
	static copyTo(this1,target) {
		let self = this1;
		let self1 = self;
		let value = self1.m00;
		let self2 = target;
		self2.m00 = value;
		let self3 = self;
		let value1 = self3.m10;
		let self4 = target;
		self4.m10 = value1;
		let self5 = self;
		let value2 = self5.m20;
		let self6 = target;
		self6.m20 = value2;
		let self7 = self;
		let value3 = self7.m30;
		let self8 = target;
		self8.m30 = value3;
		let self9 = self;
		let value4 = self9.m01;
		let self10 = target;
		self10.m01 = value4;
		let self11 = self;
		let value5 = self11.m11;
		let self12 = target;
		self12.m11 = value5;
		let self13 = self;
		let value6 = self13.m21;
		let self14 = target;
		self14.m21 = value6;
		let self15 = self;
		let value7 = self15.m31;
		let self16 = target;
		self16.m31 = value7;
		let self17 = self;
		let value8 = self17.m02;
		let self18 = target;
		self18.m02 = value8;
		let self19 = self;
		let value9 = self19.m12;
		let self20 = target;
		self20.m12 = value9;
		let self21 = self;
		let value10 = self21.m22;
		let self22 = target;
		self22.m22 = value10;
		let self23 = self;
		let value11 = self23.m32;
		let self24 = target;
		self24.m32 = value11;
		let self25 = self;
		let value12 = self25.m03;
		let self26 = target;
		self26.m03 = value12;
		let self27 = self;
		let value13 = self27.m13;
		let self28 = target;
		self28.m13 = value13;
		let self29 = self;
		let value14 = self29.m23;
		let self30 = target;
		self30.m23 = value14;
		let self31 = self;
		let value15 = self31.m33;
		let self32 = target;
		self32.m33 = value15;
	}
	static copyToShape(this1,target) {
		let self = this1;
		target.m00 = self.m00;
		target.m01 = self.m01;
		target.m02 = self.m02;
		target.m03 = self.m03;
		target.m10 = self.m10;
		target.m11 = self.m11;
		target.m12 = self.m12;
		target.m13 = self.m13;
		target.m20 = self.m20;
		target.m21 = self.m21;
		target.m22 = self.m22;
		target.m23 = self.m23;
		target.m30 = self.m30;
		target.m31 = self.m31;
		target.m32 = self.m32;
		target.m33 = self.m33;
	}
	static copyFromShape(this1,source) {
		let self = this1;
		self.m00 = source.m00;
		self.m01 = source.m01;
		self.m02 = source.m02;
		self.m03 = source.m03;
		self.m10 = source.m10;
		self.m11 = source.m11;
		self.m12 = source.m12;
		self.m13 = source.m13;
		self.m20 = source.m20;
		self.m21 = source.m21;
		self.m22 = source.m22;
		self.m23 = source.m23;
		self.m30 = source.m30;
		self.m31 = source.m31;
		self.m32 = source.m32;
		self.m33 = source.m33;
	}
	static setRotateFromQuaternion(this1,q) {
		let self = this1;
		let s = q.s;
		let x = q.x;
		let y = q.y;
		let z = q.z;
		self.m00 = 1 - 2 * (y * y + z * z);
		self.m10 = 2 * (x * y - s * z);
		self.m20 = 2 * (s * y + x * z);
		self.m01 = 2 * (x * y + s * z);
		self.m11 = 1 - 2 * (x * x + z * z);
		self.m21 = 2 * (y * z - s * x);
		self.m02 = 2 * (x * z - s * y);
		self.m12 = 2 * (y * z + s * x);
		self.m22 = 1 - 2 * (x * x + y * y);
		return self;
	}
	static setTranslate(this1,x,y,z) {
		let self = this1;
		self.m30 = x;
		self.m31 = y;
		self.m32 = z;
		self.m33 = 1.0;
		return self;
	}
	static clone(this1) {
		let self = this1;
		return new hxmath_math_Matrix4x4Default(self.m00,self.m10,self.m20,self.m30,self.m01,self.m11,self.m21,self.m31,self.m02,self.m12,self.m22,self.m32,self.m03,self.m13,self.m23,self.m33);
	}
	static getArrayElement(this1,i) {
		let self = this1;
		switch(i) {
		case 0:
			return self.m00;
		case 1:
			return self.m10;
		case 2:
			return self.m20;
		case 3:
			return self.m30;
		case 4:
			return self.m01;
		case 5:
			return self.m11;
		case 6:
			return self.m21;
		case 7:
			return self.m31;
		case 8:
			return self.m02;
		case 9:
			return self.m12;
		case 10:
			return self.m22;
		case 11:
			return self.m32;
		case 12:
			return self.m03;
		case 13:
			return self.m13;
		case 14:
			return self.m23;
		case 15:
			return self.m33;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static setArrayElement(this1,i,value) {
		let self = this1;
		switch(i) {
		case 0:
			return self.m00 = value;
		case 1:
			return self.m10 = value;
		case 2:
			return self.m20 = value;
		case 3:
			return self.m30 = value;
		case 4:
			return self.m01 = value;
		case 5:
			return self.m11 = value;
		case 6:
			return self.m21 = value;
		case 7:
			return self.m31 = value;
		case 8:
			return self.m02 = value;
		case 9:
			return self.m12 = value;
		case 10:
			return self.m22 = value;
		case 11:
			return self.m32 = value;
		case 12:
			return self.m03 = value;
		case 13:
			return self.m13 = value;
		case 14:
			return self.m23 = value;
		case 15:
			return self.m33 = value;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static getElement(this1,column,row) {
		let self = this1;
		let self1 = self;
		switch(row * 4 + column) {
		case 0:
			return self1.m00;
		case 1:
			return self1.m10;
		case 2:
			return self1.m20;
		case 3:
			return self1.m30;
		case 4:
			return self1.m01;
		case 5:
			return self1.m11;
		case 6:
			return self1.m21;
		case 7:
			return self1.m31;
		case 8:
			return self1.m02;
		case 9:
			return self1.m12;
		case 10:
			return self1.m22;
		case 11:
			return self1.m32;
		case 12:
			return self1.m03;
		case 13:
			return self1.m13;
		case 14:
			return self1.m23;
		case 15:
			return self1.m33;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static setElement(this1,column,row,value) {
		let self = this1;
		let self1 = self;
		switch(row * 4 + column) {
		case 0:
			return self1.m00 = value;
		case 1:
			return self1.m10 = value;
		case 2:
			return self1.m20 = value;
		case 3:
			return self1.m30 = value;
		case 4:
			return self1.m01 = value;
		case 5:
			return self1.m11 = value;
		case 6:
			return self1.m21 = value;
		case 7:
			return self1.m31 = value;
		case 8:
			return self1.m02 = value;
		case 9:
			return self1.m12 = value;
		case 10:
			return self1.m22 = value;
		case 11:
			return self1.m32 = value;
		case 12:
			return self1.m03 = value;
		case 13:
			return self1.m13 = value;
		case 14:
			return self1.m23 = value;
		case 15:
			return self1.m33 = value;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static col(this1,index) {
		let self = this1;
		switch(index) {
		case 0:
			return new hxmath_math_Vector4Default(self.m00,self.m01,self.m02,self.m03);
		case 1:
			return new hxmath_math_Vector4Default(self.m10,self.m11,self.m12,self.m13);
		case 2:
			return new hxmath_math_Vector4Default(self.m20,self.m21,self.m22,self.m23);
		case 3:
			return new hxmath_math_Vector4Default(self.m30,self.m31,self.m32,self.m33);
		default:
			throw haxe_Exception.thrown("Invalid column");
		}
	}
	static row(this1,index) {
		let self = this1;
		switch(index) {
		case 0:
			return new hxmath_math_Vector4Default(self.m00,self.m10,self.m20,self.m30);
		case 1:
			return new hxmath_math_Vector4Default(self.m01,self.m11,self.m21,self.m31);
		case 2:
			return new hxmath_math_Vector4Default(self.m02,self.m12,self.m22,self.m32);
		case 3:
			return new hxmath_math_Vector4Default(self.m03,self.m13,self.m23,self.m33);
		default:
			throw haxe_Exception.thrown("Invalid row");
		}
	}
	static applyScalarFunc(this1,func) {
		let self = this1;
		let self1 = self;
		let value = func(self1.m00);
		let self2 = self;
		self2.m00 = value;
		let self3 = self;
		let value1 = func(self3.m10);
		let self4 = self;
		self4.m10 = value1;
		let self5 = self;
		let value2 = func(self5.m20);
		let self6 = self;
		self6.m20 = value2;
		let self7 = self;
		let value3 = func(self7.m30);
		let self8 = self;
		self8.m30 = value3;
		let self9 = self;
		let value4 = func(self9.m01);
		let self10 = self;
		self10.m01 = value4;
		let self11 = self;
		let value5 = func(self11.m11);
		let self12 = self;
		self12.m11 = value5;
		let self13 = self;
		let value6 = func(self13.m21);
		let self14 = self;
		self14.m21 = value6;
		let self15 = self;
		let value7 = func(self15.m31);
		let self16 = self;
		self16.m31 = value7;
		let self17 = self;
		let value8 = func(self17.m02);
		let self18 = self;
		self18.m02 = value8;
		let self19 = self;
		let value9 = func(self19.m12);
		let self20 = self;
		self20.m12 = value9;
		let self21 = self;
		let value10 = func(self21.m22);
		let self22 = self;
		self22.m22 = value10;
		let self23 = self;
		let value11 = func(self23.m32);
		let self24 = self;
		self24.m32 = value11;
		let self25 = self;
		let value12 = func(self25.m03);
		let self26 = self;
		self26.m03 = value12;
		let self27 = self;
		let value13 = func(self27.m13);
		let self28 = self;
		self28.m13 = value13;
		let self29 = self;
		let value14 = func(self29.m23);
		let self30 = self;
		self30.m23 = value14;
		let self31 = self;
		let value15 = func(self31.m33);
		let self32 = self;
		self32.m33 = value15;
		return self;
	}
	static applySubMatrixTranspose(this1) {
		let self = this1;
		let temp = self.m01;
		self.m01 = self.m10;
		self.m10 = temp;
		temp = self.m02;
		self.m02 = self.m20;
		self.m20 = temp;
		temp = self.m12;
		self.m12 = self.m21;
		self.m21 = temp;
		return self;
	}
	static applyInvertFrame(this1) {
		let self = this1;
		let self1 = self;
		let temp = self1.m01;
		self1.m01 = self1.m10;
		self1.m10 = temp;
		temp = self1.m02;
		self1.m02 = self1.m20;
		self1.m20 = temp;
		temp = self1.m12;
		self1.m12 = self1.m21;
		self1.m21 = temp;
		let tx = -(self.m00 * self.m30 + self.m10 * self.m31 + self.m20 * self.m32);
		let ty = -(self.m01 * self.m30 + self.m11 * self.m31 + self.m21 * self.m32);
		let tz = -(self.m02 * self.m30 + self.m12 * self.m31 + self.m22 * self.m32);
		self.m30 = tx;
		self.m31 = ty;
		self.m32 = tz;
		return self;
	}
	static get_zero() {
		return new hxmath_math_Matrix4x4Default(0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0);
	}
	static get_identity() {
		return new hxmath_math_Matrix4x4Default(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0);
	}
	static get_t(this1) {
		let self = this1;
		return new hxmath_math_Vector3Default(self.m30,self.m31,self.m32);
	}
	static set_t(this1,t) {
		let self = this1;
		self.m30 = t.x;
		self.m31 = t.y;
		self.m32 = t.z;
		return t;
	}
	static get_transpose(this1) {
		let self = this1;
		return new hxmath_math_Matrix4x4Default(self.m00,self.m01,self.m02,self.m03,self.m10,self.m11,self.m12,self.m13,self.m20,self.m21,self.m22,self.m23,self.m30,self.m31,self.m32,self.m33);
	}
	static get_det(this1) {
		let self = this1;
		let m01 = self.m01;
		let m11 = self.m11;
		let m21 = self.m21;
		let m31 = self.m31;
		let m02 = self.m02;
		let m12 = self.m12;
		let m22 = self.m22;
		let m32 = self.m32;
		let m03 = self.m03;
		let m13 = self.m13;
		let m23 = self.m23;
		let m33 = self.m33;
		return self.m00 * (m11 * (m22 * m33 - m32 * m23) - m21 * (m12 * m33 - m32 * m13) + m31 * (m12 * m23 - m22 * m13)) - self.m10 * (m01 * (m22 * m33 - m32 * m23) - m21 * (m02 * m33 - m32 * m03) + m31 * (m02 * m23 - m22 * m03)) + self.m20 * (m01 * (m12 * m33 - m32 * m13) - m11 * (m02 * m33 - m32 * m03) + m31 * (m02 * m13 - m12 * m03)) - self.m30 * (m01 * (m12 * m23 - m22 * m13) - m11 * (m02 * m23 - m22 * m03) + m21 * (m02 * m13 - m12 * m03));
	}
	static get_subMatrix(this1) {
		let self = this1;
		return new hxmath_math_Matrix3x3Default(self.m00,self.m10,self.m20,self.m01,self.m11,self.m21,self.m02,self.m12,self.m22);
	}
}
class hxmath_math_QuaternionDefault {
	constructor(s,x,y,z) {
		this.s = s;
		this.x = x;
		this.y = y;
		this.z = z;
	}
	toString() {
		return "[" + this.s + ", (" + this.x + ", " + this.y + ", " + this.z + ")]";
	}
}
hxmath_math_QuaternionDefault.__name__ = true;
class hxmath_math_Quaternion {
	static _new(s,x,y,z) {
		return new hxmath_math_QuaternionDefault(s,x,y,z);
	}
	static fromArray(rawData) {
		if(rawData.length != 4) {
			throw haxe_Exception.thrown("Invalid rawData.");
		}
		return new hxmath_math_QuaternionDefault(rawData[0],rawData[1],rawData[2],rawData[3]);
	}
	static fromAxisAngle(angleDegrees,axis) {
		let angleRadians = Math.PI / 180 * angleDegrees;
		let cosHalfAngle = Math.cos(angleRadians / 2.0);
		let sinHalfAngle = Math.sin(angleRadians / 2.0);
		return new hxmath_math_QuaternionDefault(cosHalfAngle,sinHalfAngle * axis.x,sinHalfAngle * axis.y,sinHalfAngle * axis.z);
	}
	static multiplyScalar(a,s) {
		let self = a;
		let self1 = new hxmath_math_QuaternionDefault(self.s,self.x,self.y,self.z);
		self1.s *= s;
		self1.x *= s;
		self1.y *= s;
		self1.z *= s;
		return self1;
	}
	static multiply(a,b) {
		return new hxmath_math_QuaternionDefault(a.s * b.s - a.x * b.x - a.y * b.y - a.z * b.z,a.s * b.x + b.s * a.x + a.y * b.z - a.z * b.y,a.s * b.y + b.s * a.y + a.z * b.x - a.x * b.z,a.s * b.z + b.s * a.z + a.x * b.y - a.y * b.x);
	}
	static add(a,b) {
		let self = a;
		let self1 = new hxmath_math_QuaternionDefault(self.s,self.x,self.y,self.z);
		self1.s += b.s;
		self1.x += b.x;
		self1.y += b.y;
		self1.z += b.z;
		return self1;
	}
	static subtract(a,b) {
		let self = a;
		let self1 = new hxmath_math_QuaternionDefault(self.s,self.x,self.y,self.z);
		self1.s -= b.s;
		self1.x -= b.x;
		self1.y -= b.y;
		self1.z -= b.z;
		return self1;
	}
	static conjugate(a) {
		return new hxmath_math_QuaternionDefault(a.s,-a.x,-a.y,-a.z);
	}
	static negate(a) {
		return new hxmath_math_QuaternionDefault(-a.s,-a.x,-a.y,-a.z);
	}
	static equals(a,b) {
		if(!(a == null && b == null)) {
			if(a != null && b != null && a.s == b.s && a.x == b.x && a.y == b.y) {
				return a.z == b.z;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static lerp(a,b,t) {
		let lhs = 1.0 - t;
		let self = a;
		let self1 = new hxmath_math_QuaternionDefault(self.s,self.x,self.y,self.z);
		self1.s *= lhs;
		self1.x *= lhs;
		self1.y *= lhs;
		self1.z *= lhs;
		let lhs1 = t;
		let self2 = b;
		let self3 = new hxmath_math_QuaternionDefault(self2.s,self2.x,self2.y,self2.z);
		self3.s *= lhs1;
		self3.x *= lhs1;
		self3.y *= lhs1;
		self3.z *= lhs1;
		let b1 = self3;
		let self4 = self1;
		let self5 = new hxmath_math_QuaternionDefault(self4.s,self4.x,self4.y,self4.z);
		self5.s += b1.s;
		self5.x += b1.x;
		self5.y += b1.y;
		self5.z += b1.z;
		return self5;
	}
	static slerp(a,b,t) {
		let cosHalfTheta = a.s * b.s + a.x * b.x + a.y * b.y + a.z * b.z;
		if(Math.abs(cosHalfTheta) >= 1.0) {
			return a;
		}
		let halfTheta = Math.acos(cosHalfTheta);
		let sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);
		if(Math.abs(sinHalfTheta) < 1e-3) {
			let lhs = 1.0 - t;
			let self = a;
			let self1 = new hxmath_math_QuaternionDefault(self.s,self.x,self.y,self.z);
			self1.s *= lhs;
			self1.x *= lhs;
			self1.y *= lhs;
			self1.z *= lhs;
			let lhs1 = t;
			let self2 = b;
			let self3 = new hxmath_math_QuaternionDefault(self2.s,self2.x,self2.y,self2.z);
			self3.s *= lhs1;
			self3.x *= lhs1;
			self3.y *= lhs1;
			self3.z *= lhs1;
			let b1 = self3;
			let self4 = self1;
			let self5 = new hxmath_math_QuaternionDefault(self4.s,self4.x,self4.y,self4.z);
			self5.s += b1.s;
			self5.x += b1.x;
			self5.y += b1.y;
			self5.z += b1.z;
			let self6 = self5;
			let self7 = self6;
			let length = Math.sqrt(self7.s * self7.s + self7.x * self7.x + self7.y * self7.y + self7.z * self7.z);
			if(length > 0.0) {
				let k = 1.0 / length;
				let self = self6;
				self.s *= k;
				self.x *= k;
				self.y *= k;
				self.z *= k;
			}
			return self6;
		}
		let ta = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
		let tb = Math.sin(t * halfTheta) / sinHalfTheta;
		let result = new hxmath_math_QuaternionDefault(0,0,0,0);
		result.x = a.x * ta + b.x * tb;
		result.y = a.y * ta + b.y * tb;
		result.z = a.z * ta + b.z * tb;
		result.s = a.s * ta + b.s * tb;
		return result;
	}
	static dot(a,b) {
		return a.s * b.s + a.x * b.x + a.y * b.y + a.z * b.z;
	}
	static set(this1,s,x,y,z) {
		let self = this1;
		self.s = s;
		self.x = x;
		self.y = y;
		self.z = z;
		return self;
	}
	static invert(this1) {
		let self = this1;
		let self1 = self;
		let self2 = new hxmath_math_QuaternionDefault(self1.s,self1.x,self1.y,self1.z);
		let self3 = self2;
		self3.x = -self3.x;
		self3.y = -self3.y;
		self3.z = -self3.z;
		let self4 = self3;
		let self5 = self4;
		let length = Math.sqrt(self5.s * self5.s + self5.x * self5.x + self5.y * self5.y + self5.z * self5.z);
		if(length > 0.0) {
			let k = 1.0 / length;
			let self = self4;
			self.s *= k;
			self.x *= k;
			self.y *= k;
			self.z *= k;
		}
		return self4;
	}
	static multiplyWithScalar(this1,s) {
		let self = this1;
		self.s *= s;
		self.x *= s;
		self.y *= s;
		self.z *= s;
		return self;
	}
	static addWith(this1,a) {
		let self = this1;
		self.s += a.s;
		self.x += a.x;
		self.y += a.y;
		self.z += a.z;
		return self;
	}
	static subtractWith(this1,a) {
		let self = this1;
		self.s -= a.s;
		self.x -= a.x;
		self.y -= a.y;
		self.z -= a.z;
		return self;
	}
	static copyTo(this1,target) {
		let self = this1;
		let self1 = self;
		let value = self1.s;
		let self2 = target;
		self2.s = value;
		let self3 = self;
		let value1 = self3.x;
		let self4 = target;
		self4.x = value1;
		let self5 = self;
		let value2 = self5.y;
		let self6 = target;
		self6.y = value2;
		let self7 = self;
		let value3 = self7.z;
		let self8 = target;
		self8.z = value3;
	}
	static copyToShape(this1,target) {
		let self = this1;
		target.s = self.s;
		target.x = self.x;
		target.y = self.y;
		target.z = self.z;
	}
	static copyFromShape(this1,source) {
		let self = this1;
		self.s = source.s;
		self.x = source.x;
		self.y = source.y;
		self.z = source.z;
	}
	static clone(this1) {
		let self = this1;
		return new hxmath_math_QuaternionDefault(self.s,self.x,self.y,self.z);
	}
	static getArrayElement(this1,i) {
		let self = this1;
		switch(i) {
		case 0:
			return self.s;
		case 1:
			return self.x;
		case 2:
			return self.y;
		case 3:
			return self.z;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static setArrayElement(this1,i,value) {
		let self = this1;
		switch(i) {
		case 0:
			return self.s = value;
		case 1:
			return self.x = value;
		case 2:
			return self.y = value;
		case 3:
			return self.z = value;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static applyScalarFunc(this1,func) {
		let self = this1;
		let self1 = self;
		let value = func(self1.s);
		let self2 = self;
		self2.s = value;
		let self3 = self;
		let value1 = func(self3.x);
		let self4 = self;
		self4.x = value1;
		let self5 = self;
		let value2 = func(self5.y);
		let self6 = self;
		self6.y = value2;
		let self7 = self;
		let value3 = func(self7.z);
		let self8 = self;
		self8.z = value3;
		return self;
	}
	static log(this1) {
		let self = this1;
		let theta = Math.acos(self.s);
		let sinTheta = Math.sin(theta);
		if(sinTheta > 0.0) {
			let k = theta / sinTheta;
			return new hxmath_math_QuaternionDefault(0.0,k * self.x,k * self.y,k * self.z);
		} else {
			return new hxmath_math_QuaternionDefault(0,0,0,0);
		}
	}
	static exp(this1) {
		let self = this1;
		let theta = Math.sqrt(self.x * self.x + self.y * self.y + self.z * self.z);
		let sinTheta = Math.sin(theta);
		let cosTheta = Math.cos(theta);
		if(theta > 0.0) {
			return new hxmath_math_QuaternionDefault(cosTheta,sinTheta * self.x,sinTheta * self.y,sinTheta * self.z);
		} else {
			return new hxmath_math_QuaternionDefault(cosTheta,0,0,0);
		}
	}
	static rotate(this1,u) {
		let self = this1;
		let a = 2.0 * (self.x * u.x + self.y * u.y + self.z * u.z);
		let b = self.s * self.s - self.x * self.x - self.y * self.y - self.z * self.z;
		let c = 2.0 * self.s;
		return new hxmath_math_Vector3Default(a * self.x + b * u.x + c * (self.y * u.z - self.z * u.y),a * self.y + b * u.y + c * (self.z * u.x - self.x * u.z),a * self.z + b * u.z + c * (self.x * u.y - self.y * u.x));
	}
	static angleWith(this1,b) {
		let self = this1;
		let self1 = self;
		let self2 = b;
		return 2.0 * Math.acos((self.s * b.s + self.x * b.x + self.y * b.y + self.z * b.z) / (Math.sqrt(self1.s * self1.s + self1.x * self1.x + self1.y * self1.y + self1.z * self1.z) * Math.sqrt(self2.s * self2.s + self2.x * self2.x + self2.y * self2.y + self2.z * self2.z)));
	}
	static normalize(this1) {
		let self = this1;
		let self1 = self;
		let length = Math.sqrt(self1.s * self1.s + self1.x * self1.x + self1.y * self1.y + self1.z * self1.z);
		if(length > 0.0) {
			let k = 1.0 / length;
			let self1 = self;
			self1.s *= k;
			self1.x *= k;
			self1.y *= k;
			self1.z *= k;
		}
		return self;
	}
	static applyConjugate(this1) {
		let self = this1;
		self.x = -self.x;
		self.y = -self.y;
		self.z = -self.z;
		return self;
	}
	static applyInvert(this1) {
		let self = this1;
		let self1 = self;
		self1.x = -self1.x;
		self1.y = -self1.y;
		self1.z = -self1.z;
		let self2 = self1;
		let self3 = self2;
		let length = Math.sqrt(self3.s * self3.s + self3.x * self3.x + self3.y * self3.y + self3.z * self3.z);
		if(length > 0.0) {
			let k = 1.0 / length;
			let self = self2;
			self.s *= k;
			self.x *= k;
			self.y *= k;
			self.z *= k;
		}
		return self2;
	}
	static get_zero() {
		return new hxmath_math_QuaternionDefault(0,0,0,0);
	}
	static get_identity() {
		return new hxmath_math_QuaternionDefault(1,0,0,0);
	}
	static get_length(this1) {
		let self = this1;
		return Math.sqrt(self.s * self.s + self.x * self.x + self.y * self.y + self.z * self.z);
	}
	static get_lengthSq(this1) {
		let self = this1;
		return self.s * self.s + self.x * self.x + self.y * self.y + self.z * self.z;
	}
	static get_matrix(this1) {
		let self = this1;
		let s = self.s;
		let x = self.x;
		let y = self.y;
		let z = self.z;
		let m = new hxmath_math_Matrix3x3Default(1 - 2 * (y * y + z * z),2 * (x * y - s * z),2 * (s * y + x * z),2 * (x * y + s * z),1 - 2 * (x * x + z * z),2 * (y * z - s * x),2 * (x * z - s * y),2 * (y * z + s * x),1 - 2 * (x * x + y * y));
		return m;
	}
	static get_normal(this1) {
		let self = this1;
		let self1 = self;
		let lhs = 1.0 / Math.sqrt(self1.s * self1.s + self1.x * self1.x + self1.y * self1.y + self1.z * self1.z);
		let self2 = self;
		let self3 = new hxmath_math_QuaternionDefault(self2.s,self2.x,self2.y,self2.z);
		self3.s *= lhs;
		self3.x *= lhs;
		self3.y *= lhs;
		self3.z *= lhs;
		return self3;
	}
}
class hxmath_math_Vector2Default {
	constructor(x,y) {
		this.x = x;
		this.y = y;
	}
	toString() {
		return "(" + this.x + ", " + this.y + ")";
	}
}
hxmath_math_Vector2Default.__name__ = true;
class hxmath_math_Vector2 {
	static _new(x,y) {
		return new hxmath_math_Vector2Default(x,y);
	}
	static fromArray(rawData) {
		if(rawData.length != 2) {
			throw haxe_Exception.thrown("Invalid rawData.");
		}
		return new hxmath_math_Vector2Default(rawData[0],rawData[1]);
	}
	static fromPolar(angle,radius) {
		return new hxmath_math_Vector2Default(radius * Math.cos(angle),radius * Math.sin(angle));
	}
	static fromVector2Shape(other) {
		return new hxmath_math_Vector2Default(other.x,other.y);
	}
	static toIntVector2(this1,func) {
		let self = this1;
		if(func == null) {
			func = function(x) {
				return x | 0;
			};
		}
		return hxmath_math_IntVector2._new(func(self.x),func(self.y));
	}
	static dot(a,b) {
		return a.x * b.x + a.y * b.y;
	}
	static multiply(a,s) {
		let self = a;
		let self1 = new hxmath_math_Vector2Default(self.x,self.y);
		self1.x *= s;
		self1.y *= s;
		return self1;
	}
	static divide(a,s) {
		let self = a;
		let self1 = new hxmath_math_Vector2Default(self.x,self.y);
		self1.x /= s;
		self1.y /= s;
		return self1;
	}
	static add(a,b) {
		let self = a;
		let self1 = new hxmath_math_Vector2Default(self.x,self.y);
		self1.x += b.x;
		self1.y += b.y;
		return self1;
	}
	static subtract(a,b) {
		let self = a;
		let self1 = new hxmath_math_Vector2Default(self.x,self.y);
		self1.x -= b.x;
		self1.y -= b.y;
		return self1;
	}
	static negate(a) {
		return new hxmath_math_Vector2Default(-a.x,-a.y);
	}
	static equals(a,b) {
		if(!(a == null && b == null)) {
			if(a != null && b != null && a.x == b.x) {
				return a.y == b.y;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static lerp(a,b,t) {
		return new hxmath_math_Vector2Default((1.0 - t) * a.x + t * b.x,(1.0 - t) * a.y + t * b.y);
	}
	static max(a,b) {
		let self = a;
		let self1 = new hxmath_math_Vector2Default(self.x,self.y);
		self1.x = Math.max(self1.x,b.x);
		self1.y = Math.max(self1.y,b.y);
		return self1;
	}
	static min(a,b) {
		let self = a;
		let self1 = new hxmath_math_Vector2Default(self.x,self.y);
		self1.x = Math.min(self1.x,b.x);
		self1.y = Math.min(self1.y,b.y);
		return self1;
	}
	static project(a,b) {
		let self = a;
		let self1 = new hxmath_math_Vector2Default(self.x,self.y);
		let s = (self1.x * b.x + self1.y * b.y) / (b.x * b.x + b.y * b.y);
		let self2 = b;
		let self3 = self2;
		let value = self3.x;
		let self4 = self1;
		self4.x = value;
		let self5 = self2;
		let value1 = self5.y;
		let self6 = self1;
		self6.y = value1;
		let self7 = self1;
		self7.x *= s;
		self7.y *= s;
		return self1;
	}
	static reflect(v,normal) {
		let self = v;
		let self1 = new hxmath_math_Vector2Default(self.x,self.y);
		let self2 = self1;
		let self3 = new hxmath_math_Vector2Default(self2.x,self2.y);
		let s = (self3.x * normal.x + self3.y * normal.y) / (normal.x * normal.x + normal.y * normal.y);
		let self4 = normal;
		let self5 = self4;
		let value = self5.x;
		let self6 = self3;
		self6.x = value;
		let self7 = self4;
		let value1 = self7.y;
		let self8 = self3;
		self8.y = value1;
		let self9 = self3;
		self9.x *= s;
		self9.y *= s;
		let projected = self3;
		let self10 = projected;
		self10.x *= 2.0;
		self10.y *= 2.0;
		let self11 = self1;
		self11.x -= projected.x;
		self11.y -= projected.y;
		return self1;
	}
	static orthoNormalize(u,v) {
		let self = u;
		let self1 = self;
		let length = Math.sqrt(self1.x * self1.x + self1.y * self1.y);
		if(length > 0.0) {
			let self1 = self;
			self1.x /= length;
			self1.y /= length;
		}
		let self2 = v;
		let self3 = new hxmath_math_Vector2Default(self2.x,self2.y);
		let s = (self3.x * u.x + self3.y * u.y) / (u.x * u.x + u.y * u.y);
		let self4 = u;
		let self5 = self4;
		let value = self5.x;
		let self6 = self3;
		self6.x = value;
		let self7 = self4;
		let value1 = self7.y;
		let self8 = self3;
		self8.y = value1;
		let self9 = self3;
		self9.x *= s;
		self9.y *= s;
		let a = self3;
		let self10 = v;
		self10.x -= a.x;
		self10.y -= a.y;
		let self11 = v;
		let self12 = self11;
		let length1 = Math.sqrt(self12.x * self12.x + self12.y * self12.y);
		if(length1 > 0.0) {
			let self = self11;
			self.x /= length1;
			self.y /= length1;
		}
	}
	static set(this1,x,y) {
		let self = this1;
		self.x = x;
		self.y = y;
		return self;
	}
	static multiplyWith(this1,s) {
		let self = this1;
		self.x *= s;
		self.y *= s;
		return self;
	}
	static divideWith(this1,s) {
		let self = this1;
		self.x /= s;
		self.y /= s;
		return self;
	}
	static addWith(this1,a) {
		let self = this1;
		self.x += a.x;
		self.y += a.y;
		return self;
	}
	static subtractWith(this1,a) {
		let self = this1;
		self.x -= a.x;
		self.y -= a.y;
		return self;
	}
	static maxWith(this1,a) {
		let self = this1;
		self.x = Math.max(self.x,a.x);
		self.y = Math.max(self.y,a.y);
		return self;
	}
	static minWith(this1,a) {
		let self = this1;
		self.x = Math.min(self.x,a.x);
		self.y = Math.min(self.y,a.y);
		return self;
	}
	static projectOnto(this1,a) {
		let self = this1;
		let s = (self.x * a.x + self.y * a.y) / (a.x * a.x + a.y * a.y);
		let self1 = a;
		let self2 = self1;
		let value = self2.x;
		let self3 = self;
		self3.x = value;
		let self4 = self1;
		let value1 = self4.y;
		let self5 = self;
		self5.y = value1;
		let self6 = self;
		self6.x *= s;
		self6.y *= s;
		return self;
	}
	static reflectBy(this1,normal) {
		let self = this1;
		let self1 = self;
		let self2 = new hxmath_math_Vector2Default(self1.x,self1.y);
		let s = (self2.x * normal.x + self2.y * normal.y) / (normal.x * normal.x + normal.y * normal.y);
		let self3 = normal;
		let self4 = self3;
		let value = self4.x;
		let self5 = self2;
		self5.x = value;
		let self6 = self3;
		let value1 = self6.y;
		let self7 = self2;
		self7.y = value1;
		let self8 = self2;
		self8.x *= s;
		self8.y *= s;
		let projected = self2;
		let self9 = projected;
		self9.x *= 2.0;
		self9.y *= 2.0;
		let self10 = self;
		self10.x -= projected.x;
		self10.y -= projected.y;
		return self;
	}
	static copyTo(this1,target) {
		let self = this1;
		let self1 = self;
		let value = self1.x;
		let self2 = target;
		self2.x = value;
		let self3 = self;
		let value1 = self3.y;
		let self4 = target;
		self4.y = value1;
	}
	static copyToShape(this1,target) {
		let self = this1;
		target.x = self.x;
		target.y = self.y;
	}
	static copyFromShape(this1,source) {
		let self = this1;
		self.x = source.x;
		self.y = source.y;
	}
	static clone(this1) {
		let self = this1;
		return new hxmath_math_Vector2Default(self.x,self.y);
	}
	static getArrayElement(this1,i) {
		let self = this1;
		switch(i) {
		case 0:
			return self.x;
		case 1:
			return self.y;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static setArrayElement(this1,i,value) {
		let self = this1;
		switch(i) {
		case 0:
			return self.x = value;
		case 1:
			return self.y = value;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static applyNegate(this1) {
		let self = this1;
		self.x = -self.x;
		self.y = -self.y;
		return self;
	}
	static applyScalarFunc(this1,func) {
		let self = this1;
		let self1 = self;
		let value = func(self1.x);
		let self2 = self;
		self2.x = value;
		let self3 = self;
		let value1 = func(self3.y);
		let self4 = self;
		self4.y = value1;
		return self;
	}
	static angleWith(this1,b) {
		let self = this1;
		let self1 = self;
		let self2 = b;
		return Math.acos((self.x * b.x + self.y * b.y) / (Math.sqrt(self1.x * self1.x + self1.y * self1.y) * Math.sqrt(self2.x * self2.x + self2.y * self2.y)));
	}
	static signedAngleWith(this1,b) {
		let self = this1;
		let x = self.x * b.y - b.x * self.y;
		let self1 = self;
		let self2 = self1;
		let self3 = b;
		return (Math.abs(x) < 0 ? 0 : x <= 0 ? -1 : 1) * Math.acos((self1.x * b.x + self1.y * b.y) / (Math.sqrt(self2.x * self2.x + self2.y * self2.y) * Math.sqrt(self3.x * self3.x + self3.y * self3.y)));
	}
	static distanceTo(this1,b) {
		let self = this1;
		let self1 = self;
		let self2 = new hxmath_math_Vector2Default(self1.x,self1.y);
		self2.x -= b.x;
		self2.y -= b.y;
		let self3 = self2;
		return Math.sqrt(self3.x * self3.x + self3.y * self3.y);
	}
	static normalize(this1) {
		let self = this1;
		let self1 = self;
		let length = Math.sqrt(self1.x * self1.x + self1.y * self1.y);
		if(length > 0.0) {
			let self1 = self;
			self1.x /= length;
			self1.y /= length;
		}
		return self;
	}
	static normalizeTo(this1,newLength) {
		let self = this1;
		let self1 = self;
		let self2 = self1;
		let length = Math.sqrt(self2.x * self2.x + self2.y * self2.y);
		if(length > 0.0) {
			let self = self1;
			self.x /= length;
			self.y /= length;
		}
		let self3 = self;
		self3.x *= newLength;
		self3.y *= newLength;
		return self;
	}
	static clamp(this1,min,max) {
		let self = this1;
		let self1 = self;
		let length = Math.sqrt(self1.x * self1.x + self1.y * self1.y);
		if(length < min) {
			let self1 = self;
			let self2 = self1;
			let self3 = self2;
			let length = Math.sqrt(self3.x * self3.x + self3.y * self3.y);
			if(length > 0.0) {
				let self = self2;
				self.x /= length;
				self.y /= length;
			}
			let self4 = self1;
			self4.x *= min;
			self4.y *= min;
		} else if(length > max) {
			let self1 = self;
			let self2 = self1;
			let self3 = self2;
			let length = Math.sqrt(self3.x * self3.x + self3.y * self3.y);
			if(length > 0.0) {
				let self = self2;
				self.x /= length;
				self.y /= length;
			}
			let self4 = self1;
			self4.x *= max;
			self4.y *= max;
		}
		return self;
	}
	static rotate(this1,angle,pivot) {
		let self = this1;
		let cosAngle = Math.cos(angle);
		let sinAngle = Math.sin(angle);
		let dx = self.x - pivot.x;
		let dy = self.y - pivot.y;
		self.x = dx * cosAngle - dy * sinAngle;
		self.y = dx * sinAngle + dy * cosAngle;
		return self;
	}
	static rotateLeft(this1) {
		let self = this1;
		let newX = -self.y;
		self.y = self.x;
		self.x = newX;
		return self;
	}
	static rotateRight(this1) {
		let self = this1;
		let newX = self.y;
		self.y = -self.x;
		self.x = newX;
		return self;
	}
	static get_zero() {
		return new hxmath_math_Vector2Default(0.0,0.0);
	}
	static get_xAxis() {
		return new hxmath_math_Vector2Default(1.0,0.0);
	}
	static get_yAxis() {
		return new hxmath_math_Vector2Default(0.0,1.0);
	}
	static get_length(this1) {
		let self = this1;
		return Math.sqrt(self.x * self.x + self.y * self.y);
	}
	static get_lengthSq(this1) {
		let self = this1;
		return self.x * self.x + self.y * self.y;
	}
	static get_angle(this1) {
		let self = this1;
		return Math.atan2(self.y,self.x);
	}
	static get_normal(this1) {
		let self = this1;
		let self1 = self;
		let self2 = new hxmath_math_Vector2Default(self1.x,self1.y);
		let self3 = self2;
		let length = Math.sqrt(self3.x * self3.x + self3.y * self3.y);
		if(length > 0.0) {
			let self = self2;
			self.x /= length;
			self.y /= length;
		}
		return self2;
	}
	static get_rotatedLeft(this1) {
		let self = this1;
		let self1 = self;
		let self2 = new hxmath_math_Vector2Default(self1.x,self1.y);
		let newX = -self2.y;
		self2.y = self2.x;
		self2.x = newX;
		return self2;
	}
	static get_rotatedRight(this1) {
		let self = this1;
		let self1 = self;
		let self2 = new hxmath_math_Vector2Default(self1.x,self1.y);
		let newX = self2.y;
		self2.y = -self2.x;
		self2.x = newX;
		return self2;
	}
}
class hxmath_math_Vector3Default {
	constructor(x,y,z) {
		this.x = x;
		this.y = y;
		this.z = z;
	}
	toString() {
		return "(" + this.x + ", " + this.y + ", " + this.z + ")";
	}
}
hxmath_math_Vector3Default.__name__ = true;
class hxmath_math_Vector3 {
	static _new(x,y,z) {
		return new hxmath_math_Vector3Default(x,y,z);
	}
	static fromArray(rawData) {
		if(rawData.length != 3) {
			throw haxe_Exception.thrown("Invalid rawData.");
		}
		return new hxmath_math_Vector3Default(rawData[0],rawData[1],rawData[2]);
	}
	static fromVector3Shape(other) {
		return new hxmath_math_Vector3Default(other.x,other.y,other.z);
	}
	static dot(a,b) {
		return a.x * b.x + a.y * b.y + a.z * b.z;
	}
	static cross(a,b) {
		let self = a;
		let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
		let newX = self1.y * b.z - self1.z * b.y;
		let newY = self1.z * b.x - self1.x * b.z;
		let newZ = self1.x * b.y - self1.y * b.x;
		self1.x = newX;
		self1.y = newY;
		self1.z = newZ;
		return self1;
	}
	static multiply(a,s) {
		let self = a;
		let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
		self1.x *= s;
		self1.y *= s;
		self1.z *= s;
		return self1;
	}
	static divide(a,s) {
		let self = a;
		let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
		self1.x /= s;
		self1.y /= s;
		self1.z /= s;
		return self1;
	}
	static add(a,b) {
		let self = a;
		let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
		self1.x += b.x;
		self1.y += b.y;
		self1.z += b.z;
		return self1;
	}
	static subtract(a,b) {
		let self = a;
		let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
		self1.x -= b.x;
		self1.y -= b.y;
		self1.z -= b.z;
		return self1;
	}
	static negate(a) {
		return new hxmath_math_Vector3Default(-a.x,-a.y,-a.z);
	}
	static equals(a,b) {
		if(!(a == null && b == null)) {
			if(a != null && b != null && a.x == b.x && a.y == b.y) {
				return a.z == b.z;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static lerp(a,b,t) {
		return new hxmath_math_Vector3Default((1.0 - t) * a.x + t * b.x,(1.0 - t) * a.y + t * b.y,(1.0 - t) * a.z + t * b.z);
	}
	static max(a,b) {
		let self = a;
		let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
		self1.x = Math.max(self1.x,b.x);
		self1.y = Math.max(self1.y,b.y);
		self1.z = Math.max(self1.z,b.z);
		return self1;
	}
	static min(a,b) {
		let self = a;
		let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
		self1.x = Math.min(self1.x,b.x);
		self1.y = Math.min(self1.y,b.y);
		self1.z = Math.min(self1.z,b.z);
		return self1;
	}
	static project(a,b) {
		let self = a;
		let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
		let s = (self1.x * b.x + self1.y * b.y + self1.z * b.z) / (b.x * b.x + b.y * b.y + b.z * b.z);
		let self2 = b;
		let self3 = self2;
		let value = self3.x;
		let self4 = self1;
		self4.x = value;
		let self5 = self2;
		let value1 = self5.y;
		let self6 = self1;
		self6.y = value1;
		let self7 = self2;
		let value2 = self7.z;
		let self8 = self1;
		self8.z = value2;
		let self9 = self1;
		self9.x *= s;
		self9.y *= s;
		self9.z *= s;
		return self1;
	}
	static reflect(v,normal) {
		let self = v;
		let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
		let self2 = self1;
		let self3 = new hxmath_math_Vector3Default(self2.x,self2.y,self2.z);
		let s = (self3.x * normal.x + self3.y * normal.y + self3.z * normal.z) / (normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
		let self4 = normal;
		let self5 = self4;
		let value = self5.x;
		let self6 = self3;
		self6.x = value;
		let self7 = self4;
		let value1 = self7.y;
		let self8 = self3;
		self8.y = value1;
		let self9 = self4;
		let value2 = self9.z;
		let self10 = self3;
		self10.z = value2;
		let self11 = self3;
		self11.x *= s;
		self11.y *= s;
		self11.z *= s;
		let projected = self3;
		let self12 = projected;
		self12.x *= 2.0;
		self12.y *= 2.0;
		self12.z *= 2.0;
		let self13 = self1;
		self13.x -= projected.x;
		self13.y -= projected.y;
		self13.z -= projected.z;
		return self1;
	}
	static orthoNormalize(u,v,w) {
		let self = u;
		let self1 = self;
		let length = Math.sqrt(self1.x * self1.x + self1.y * self1.y + self1.z * self1.z);
		if(length > 0.0) {
			let self1 = self;
			self1.x /= length;
			self1.y /= length;
			self1.z /= length;
		}
		let self2 = v;
		let self3 = new hxmath_math_Vector3Default(self2.x,self2.y,self2.z);
		let s = (self3.x * u.x + self3.y * u.y + self3.z * u.z) / (u.x * u.x + u.y * u.y + u.z * u.z);
		let self4 = u;
		let self5 = self4;
		let value = self5.x;
		let self6 = self3;
		self6.x = value;
		let self7 = self4;
		let value1 = self7.y;
		let self8 = self3;
		self8.y = value1;
		let self9 = self4;
		let value2 = self9.z;
		let self10 = self3;
		self10.z = value2;
		let self11 = self3;
		self11.x *= s;
		self11.y *= s;
		self11.z *= s;
		let a = self3;
		let self12 = v;
		self12.x -= a.x;
		self12.y -= a.y;
		self12.z -= a.z;
		let self13 = v;
		let self14 = self13;
		let length1 = Math.sqrt(self14.x * self14.x + self14.y * self14.y + self14.z * self14.z);
		if(length1 > 0.0) {
			let self = self13;
			self.x /= length1;
			self.y /= length1;
			self.z /= length1;
		}
		let self15 = w;
		let self16 = new hxmath_math_Vector3Default(self15.x,self15.y,self15.z);
		let s1 = (self16.x * u.x + self16.y * u.y + self16.z * u.z) / (u.x * u.x + u.y * u.y + u.z * u.z);
		let self17 = u;
		let self18 = self17;
		let value3 = self18.x;
		let self19 = self16;
		self19.x = value3;
		let self20 = self17;
		let value4 = self20.y;
		let self21 = self16;
		self21.y = value4;
		let self22 = self17;
		let value5 = self22.z;
		let self23 = self16;
		self23.z = value5;
		let self24 = self16;
		self24.x *= s1;
		self24.y *= s1;
		self24.z *= s1;
		let a1 = self16;
		let self25 = w;
		self25.x -= a1.x;
		self25.y -= a1.y;
		self25.z -= a1.z;
		let self26 = w;
		let self27 = new hxmath_math_Vector3Default(self26.x,self26.y,self26.z);
		let s2 = (self27.x * v.x + self27.y * v.y + self27.z * v.z) / (v.x * v.x + v.y * v.y + v.z * v.z);
		let self28 = v;
		let self29 = self28;
		let value6 = self29.x;
		let self30 = self27;
		self30.x = value6;
		let self31 = self28;
		let value7 = self31.y;
		let self32 = self27;
		self32.y = value7;
		let self33 = self28;
		let value8 = self33.z;
		let self34 = self27;
		self34.z = value8;
		let self35 = self27;
		self35.x *= s2;
		self35.y *= s2;
		self35.z *= s2;
		let a2 = self27;
		let self36 = w;
		self36.x -= a2.x;
		self36.y -= a2.y;
		self36.z -= a2.z;
		let self37 = w;
		let self38 = self37;
		let length2 = Math.sqrt(self38.x * self38.x + self38.y * self38.y + self38.z * self38.z);
		if(length2 > 0.0) {
			let self = self37;
			self.x /= length2;
			self.y /= length2;
			self.z /= length2;
		}
	}
	static set(this1,x,y,z) {
		let self = this1;
		self.x = x;
		self.y = y;
		self.z = z;
		return self;
	}
	static crossWith(this1,a) {
		let self = this1;
		let newX = self.y * a.z - self.z * a.y;
		let newY = self.z * a.x - self.x * a.z;
		let newZ = self.x * a.y - self.y * a.x;
		self.x = newX;
		self.y = newY;
		self.z = newZ;
		return self;
	}
	static multiplyWith(this1,s) {
		let self = this1;
		self.x *= s;
		self.y *= s;
		self.z *= s;
		return self;
	}
	static divideWith(this1,s) {
		let self = this1;
		self.x /= s;
		self.y /= s;
		self.z /= s;
		return self;
	}
	static addWith(this1,a) {
		let self = this1;
		self.x += a.x;
		self.y += a.y;
		self.z += a.z;
		return self;
	}
	static subtractWith(this1,a) {
		let self = this1;
		self.x -= a.x;
		self.y -= a.y;
		self.z -= a.z;
		return self;
	}
	static maxWith(this1,a) {
		let self = this1;
		self.x = Math.max(self.x,a.x);
		self.y = Math.max(self.y,a.y);
		self.z = Math.max(self.z,a.z);
		return self;
	}
	static minWith(this1,a) {
		let self = this1;
		self.x = Math.min(self.x,a.x);
		self.y = Math.min(self.y,a.y);
		self.z = Math.min(self.z,a.z);
		return self;
	}
	static projectOnto(this1,a) {
		let self = this1;
		let s = (self.x * a.x + self.y * a.y + self.z * a.z) / (a.x * a.x + a.y * a.y + a.z * a.z);
		let self1 = a;
		let self2 = self1;
		let value = self2.x;
		let self3 = self;
		self3.x = value;
		let self4 = self1;
		let value1 = self4.y;
		let self5 = self;
		self5.y = value1;
		let self6 = self1;
		let value2 = self6.z;
		let self7 = self;
		self7.z = value2;
		let self8 = self;
		self8.x *= s;
		self8.y *= s;
		self8.z *= s;
		return self;
	}
	static projectOntoPlane(this1,normal) {
		let self = this1;
		let self1 = self;
		let self2 = new hxmath_math_Vector3Default(self1.x,self1.y,self1.z);
		let s = (self2.x * normal.x + self2.y * normal.y + self2.z * normal.z) / (normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
		let self3 = normal;
		let self4 = self3;
		let value = self4.x;
		let self5 = self2;
		self5.x = value;
		let self6 = self3;
		let value1 = self6.y;
		let self7 = self2;
		self7.y = value1;
		let self8 = self3;
		let value2 = self8.z;
		let self9 = self2;
		self9.z = value2;
		let self10 = self2;
		self10.x *= s;
		self10.y *= s;
		self10.z *= s;
		let a = self2;
		let self11 = self;
		self11.x -= a.x;
		self11.y -= a.y;
		self11.z -= a.z;
		return self;
	}
	static reflectBy(this1,normal) {
		let self = this1;
		let self1 = self;
		let self2 = new hxmath_math_Vector3Default(self1.x,self1.y,self1.z);
		let s = (self2.x * normal.x + self2.y * normal.y + self2.z * normal.z) / (normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
		let self3 = normal;
		let self4 = self3;
		let value = self4.x;
		let self5 = self2;
		self5.x = value;
		let self6 = self3;
		let value1 = self6.y;
		let self7 = self2;
		self7.y = value1;
		let self8 = self3;
		let value2 = self8.z;
		let self9 = self2;
		self9.z = value2;
		let self10 = self2;
		self10.x *= s;
		self10.y *= s;
		self10.z *= s;
		let projected = self2;
		let self11 = projected;
		self11.x *= 2.0;
		self11.y *= 2.0;
		self11.z *= 2.0;
		let self12 = self;
		self12.x -= projected.x;
		self12.y -= projected.y;
		self12.z -= projected.z;
		return self;
	}
	static copyTo(this1,target) {
		let self = this1;
		let self1 = self;
		let value = self1.x;
		let self2 = target;
		self2.x = value;
		let self3 = self;
		let value1 = self3.y;
		let self4 = target;
		self4.y = value1;
		let self5 = self;
		let value2 = self5.z;
		let self6 = target;
		self6.z = value2;
	}
	static copyToShape(this1,target) {
		let self = this1;
		target.x = self.x;
		target.y = self.y;
		target.z = self.z;
	}
	static copyFromShape(this1,source) {
		let self = this1;
		self.x = source.x;
		self.y = source.y;
		self.z = source.z;
	}
	static clone(this1) {
		let self = this1;
		return new hxmath_math_Vector3Default(self.x,self.y,self.z);
	}
	static getArrayElement(this1,i) {
		let self = this1;
		switch(i) {
		case 0:
			return self.x;
		case 1:
			return self.y;
		case 2:
			return self.z;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static setArrayElement(this1,i,value) {
		let self = this1;
		switch(i) {
		case 0:
			return self.x = value;
		case 1:
			return self.y = value;
		case 2:
			return self.z = value;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static applyNegate(this1) {
		let self = this1;
		self.x = -self.x;
		self.y = -self.y;
		self.z = -self.z;
		return self;
	}
	static applyScalarFunc(this1,func) {
		let self = this1;
		let self1 = self;
		let value = func(self1.x);
		let self2 = self;
		self2.x = value;
		let self3 = self;
		let value1 = func(self3.y);
		let self4 = self;
		self4.y = value1;
		let self5 = self;
		let value2 = func(self5.z);
		let self6 = self;
		self6.z = value2;
		return self;
	}
	static angleWith(this1,b) {
		let self = this1;
		let self1 = self;
		let self2 = b;
		return Math.acos((self.x * b.x + self.y * b.y + self.z * b.z) / (Math.sqrt(self1.x * self1.x + self1.y * self1.y + self1.z * self1.z) * Math.sqrt(self2.x * self2.x + self2.y * self2.y + self2.z * self2.z)));
	}
	static distanceTo(this1,b) {
		let self = this1;
		let self1 = self;
		let self2 = new hxmath_math_Vector3Default(self1.x,self1.y,self1.z);
		self2.x -= b.x;
		self2.y -= b.y;
		self2.z -= b.z;
		let self3 = self2;
		return Math.sqrt(self3.x * self3.x + self3.y * self3.y + self3.z * self3.z);
	}
	static normalize(this1) {
		let self = this1;
		let self1 = self;
		let length = Math.sqrt(self1.x * self1.x + self1.y * self1.y + self1.z * self1.z);
		if(length > 0.0) {
			let self1 = self;
			self1.x /= length;
			self1.y /= length;
			self1.z /= length;
		}
		return self;
	}
	static normalizeTo(this1,newLength) {
		let self = this1;
		let self1 = self;
		let self2 = self1;
		let length = Math.sqrt(self2.x * self2.x + self2.y * self2.y + self2.z * self2.z);
		if(length > 0.0) {
			let self = self1;
			self.x /= length;
			self.y /= length;
			self.z /= length;
		}
		let self3 = self;
		self3.x *= newLength;
		self3.y *= newLength;
		self3.z *= newLength;
		return self;
	}
	static clamp(this1,min,max) {
		let self = this1;
		let self1 = self;
		let length = Math.sqrt(self1.x * self1.x + self1.y * self1.y + self1.z * self1.z);
		if(length < min) {
			let self1 = self;
			let self2 = self1;
			let self3 = self2;
			let length = Math.sqrt(self3.x * self3.x + self3.y * self3.y + self3.z * self3.z);
			if(length > 0.0) {
				let self = self2;
				self.x /= length;
				self.y /= length;
				self.z /= length;
			}
			let self4 = self1;
			self4.x *= min;
			self4.y *= min;
			self4.z *= min;
		} else if(length > max) {
			let self1 = self;
			let self2 = self1;
			let self3 = self2;
			let length = Math.sqrt(self3.x * self3.x + self3.y * self3.y + self3.z * self3.z);
			if(length > 0.0) {
				let self = self2;
				self.x /= length;
				self.y /= length;
				self.z /= length;
			}
			let self4 = self1;
			self4.x *= max;
			self4.y *= max;
			self4.z *= max;
		}
		return self;
	}
	static get_length(this1) {
		let self = this1;
		return Math.sqrt(self.x * self.x + self.y * self.y + self.z * self.z);
	}
	static get_lengthSq(this1) {
		let self = this1;
		return self.x * self.x + self.y * self.y + self.z * self.z;
	}
	static get_zero() {
		return new hxmath_math_Vector3Default(0.0,0.0,0.0);
	}
	static get_xAxis() {
		return new hxmath_math_Vector3Default(1.0,0.0,0.0);
	}
	static get_yAxis() {
		return new hxmath_math_Vector3Default(0.0,1.0,0.0);
	}
	static get_zAxis() {
		return new hxmath_math_Vector3Default(0.0,0.0,1.0);
	}
}
class hxmath_math_Vector4Default {
	constructor(x,y,z,w) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
	}
	toString() {
		return "(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";
	}
}
hxmath_math_Vector4Default.__name__ = true;
class hxmath_math_Vector4 {
	static _new(x,y,z,w) {
		return new hxmath_math_Vector4Default(x,y,z,w);
	}
	static fromArray(rawData) {
		if(rawData.length != 4) {
			throw haxe_Exception.thrown("Invalid rawData.");
		}
		return new hxmath_math_Vector4Default(rawData[0],rawData[1],rawData[2],rawData[3]);
	}
	static fromVector4Shape(other) {
		return new hxmath_math_Vector4Default(other.x,other.y,other.z,other.w);
	}
	static dot(a,b) {
		return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
	}
	static multiply(a,s) {
		let self = a;
		let self1 = new hxmath_math_Vector4Default(self.x,self.y,self.z,self.w);
		self1.x *= s;
		self1.y *= s;
		self1.z *= s;
		self1.w *= s;
		return self1;
	}
	static divide(a,s) {
		let self = a;
		let self1 = new hxmath_math_Vector4Default(self.x,self.y,self.z,self.w);
		self1.x /= s;
		self1.y /= s;
		self1.z /= s;
		self1.w /= s;
		return self1;
	}
	static add(a,b) {
		let self = a;
		let self1 = new hxmath_math_Vector4Default(self.x,self.y,self.z,self.w);
		self1.x += b.x;
		self1.y += b.y;
		self1.z += b.z;
		self1.w += b.w;
		return self1;
	}
	static subtract(a,b) {
		let self = a;
		let self1 = new hxmath_math_Vector4Default(self.x,self.y,self.z,self.w);
		self1.x -= b.x;
		self1.y -= b.y;
		self1.z -= b.z;
		self1.w -= b.w;
		return self1;
	}
	static negate(a) {
		return new hxmath_math_Vector4Default(-a.x,-a.y,-a.z,-a.w);
	}
	static equals(a,b) {
		if(!(a == null && b == null)) {
			if(a != null && b != null && a.x == b.x && a.y == b.y && a.z == b.z) {
				return a.w == b.w;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static lerp(a,b,t) {
		return new hxmath_math_Vector4Default((1.0 - t) * a.x + t * b.x,(1.0 - t) * a.y + t * b.y,(1.0 - t) * a.z + t * b.z,(1.0 - t) * a.w + t * b.w);
	}
	static max(a,b) {
		let self = a;
		let self1 = new hxmath_math_Vector4Default(self.x,self.y,self.z,self.w);
		self1.x = Math.max(self1.x,b.x);
		self1.y = Math.max(self1.y,b.y);
		self1.z = Math.max(self1.z,b.z);
		self1.w = Math.max(self1.w,b.w);
		return self1;
	}
	static min(a,b) {
		let self = a;
		let self1 = new hxmath_math_Vector4Default(self.x,self.y,self.z,self.w);
		self1.x = Math.min(self1.x,b.x);
		self1.y = Math.min(self1.y,b.y);
		self1.z = Math.min(self1.z,b.z);
		self1.w = Math.min(self1.w,b.w);
		return self1;
	}
	static project(a,b) {
		let self = a;
		let self1 = new hxmath_math_Vector4Default(self.x,self.y,self.z,self.w);
		let s = (self1.x * b.x + self1.y * b.y + self1.z * b.z + self1.w * b.w) / (b.x * b.x + b.y * b.y + b.z * b.z + b.w * b.w);
		let self2 = b;
		let self3 = self2;
		let value = self3.x;
		let self4 = self1;
		self4.x = value;
		let self5 = self2;
		let value1 = self5.y;
		let self6 = self1;
		self6.y = value1;
		let self7 = self2;
		let value2 = self7.z;
		let self8 = self1;
		self8.z = value2;
		let self9 = self2;
		let value3 = self9.w;
		let self10 = self1;
		self10.w = value3;
		let self11 = self1;
		self11.x *= s;
		self11.y *= s;
		self11.z *= s;
		self11.w *= s;
		return self1;
	}
	static set(this1,x,y,z,w) {
		let self = this1;
		self.x = x;
		self.y = y;
		self.z = z;
		self.w = w;
		return self;
	}
	static multiplyWith(this1,s) {
		let self = this1;
		self.x *= s;
		self.y *= s;
		self.z *= s;
		self.w *= s;
		return self;
	}
	static divideWith(this1,s) {
		let self = this1;
		self.x /= s;
		self.y /= s;
		self.z /= s;
		self.w /= s;
		return self;
	}
	static addWith(this1,a) {
		let self = this1;
		self.x += a.x;
		self.y += a.y;
		self.z += a.z;
		self.w += a.w;
		return self;
	}
	static subtractWith(this1,a) {
		let self = this1;
		self.x -= a.x;
		self.y -= a.y;
		self.z -= a.z;
		self.w -= a.w;
		return self;
	}
	static maxWith(this1,a) {
		let self = this1;
		self.x = Math.max(self.x,a.x);
		self.y = Math.max(self.y,a.y);
		self.z = Math.max(self.z,a.z);
		self.w = Math.max(self.w,a.w);
		return self;
	}
	static minWith(this1,a) {
		let self = this1;
		self.x = Math.min(self.x,a.x);
		self.y = Math.min(self.y,a.y);
		self.z = Math.min(self.z,a.z);
		self.w = Math.min(self.w,a.w);
		return self;
	}
	static projectOnto(this1,a) {
		let self = this1;
		let s = (self.x * a.x + self.y * a.y + self.z * a.z + self.w * a.w) / (a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
		let self1 = a;
		let self2 = self1;
		let value = self2.x;
		let self3 = self;
		self3.x = value;
		let self4 = self1;
		let value1 = self4.y;
		let self5 = self;
		self5.y = value1;
		let self6 = self1;
		let value2 = self6.z;
		let self7 = self;
		self7.z = value2;
		let self8 = self1;
		let value3 = self8.w;
		let self9 = self;
		self9.w = value3;
		let self10 = self;
		self10.x *= s;
		self10.y *= s;
		self10.z *= s;
		self10.w *= s;
		return self;
	}
	static copyTo(this1,target) {
		let self = this1;
		let self1 = self;
		let value = self1.x;
		let self2 = target;
		self2.x = value;
		let self3 = self;
		let value1 = self3.y;
		let self4 = target;
		self4.y = value1;
		let self5 = self;
		let value2 = self5.z;
		let self6 = target;
		self6.z = value2;
		let self7 = self;
		let value3 = self7.w;
		let self8 = target;
		self8.w = value3;
	}
	static copyToShape(this1,target) {
		let self = this1;
		target.x = self.x;
		target.y = self.y;
		target.z = self.z;
		target.w = self.w;
	}
	static copyFromShape(this1,source) {
		let self = this1;
		self.x = source.x;
		self.y = source.y;
		self.z = source.z;
		self.w = source.w;
	}
	static clone(this1) {
		let self = this1;
		return new hxmath_math_Vector4Default(self.x,self.y,self.z,self.w);
	}
	static getArrayElement(this1,i) {
		let self = this1;
		switch(i) {
		case 0:
			return self.x;
		case 1:
			return self.y;
		case 2:
			return self.z;
		case 3:
			return self.w;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static setArrayElement(this1,i,value) {
		let self = this1;
		switch(i) {
		case 0:
			return self.x = value;
		case 1:
			return self.y = value;
		case 2:
			return self.z = value;
		case 3:
			return self.w = value;
		default:
			throw haxe_Exception.thrown("Invalid element");
		}
	}
	static applyScalarFunc(this1,func) {
		let self = this1;
		let self1 = self;
		let value = func(self1.x);
		let self2 = self;
		self2.x = value;
		let self3 = self;
		let value1 = func(self3.y);
		let self4 = self;
		self4.y = value1;
		let self5 = self;
		let value2 = func(self5.z);
		let self6 = self;
		self6.z = value2;
		let self7 = self;
		let value3 = func(self7.w);
		let self8 = self;
		self8.w = value3;
		return self;
	}
	static distanceTo(this1,b) {
		let self = this1;
		let self1 = self;
		let self2 = new hxmath_math_Vector4Default(self1.x,self1.y,self1.z,self1.w);
		self2.x -= b.x;
		self2.y -= b.y;
		self2.z -= b.z;
		self2.w -= b.w;
		let self3 = self2;
		return Math.sqrt(self3.x * self3.x + self3.y * self3.y + self3.z * self3.z + self3.w * self3.w);
	}
	static normalize(this1) {
		let self = this1;
		let self1 = self;
		let length = Math.sqrt(self1.x * self1.x + self1.y * self1.y + self1.z * self1.z + self1.w * self1.w);
		if(length > 0.0) {
			let self1 = self;
			self1.x /= length;
			self1.y /= length;
			self1.z /= length;
			self1.w /= length;
		}
		return self;
	}
	static normalizeTo(this1,newLength) {
		let self = this1;
		let self1 = self;
		let self2 = self1;
		let length = Math.sqrt(self2.x * self2.x + self2.y * self2.y + self2.z * self2.z + self2.w * self2.w);
		if(length > 0.0) {
			let self = self1;
			self.x /= length;
			self.y /= length;
			self.z /= length;
			self.w /= length;
		}
		let self3 = self;
		self3.x *= newLength;
		self3.y *= newLength;
		self3.z *= newLength;
		self3.w *= newLength;
		return self;
	}
	static clamp(this1,min,max) {
		let self = this1;
		let self1 = self;
		let length = Math.sqrt(self1.x * self1.x + self1.y * self1.y + self1.z * self1.z + self1.w * self1.w);
		if(length < min) {
			let self1 = self;
			let self2 = self1;
			let self3 = self2;
			let length = Math.sqrt(self3.x * self3.x + self3.y * self3.y + self3.z * self3.z + self3.w * self3.w);
			if(length > 0.0) {
				let self = self2;
				self.x /= length;
				self.y /= length;
				self.z /= length;
				self.w /= length;
			}
			let self4 = self1;
			self4.x *= min;
			self4.y *= min;
			self4.z *= min;
			self4.w *= min;
		} else if(length > max) {
			let self1 = self;
			let self2 = self1;
			let self3 = self2;
			let length = Math.sqrt(self3.x * self3.x + self3.y * self3.y + self3.z * self3.z + self3.w * self3.w);
			if(length > 0.0) {
				let self = self2;
				self.x /= length;
				self.y /= length;
				self.z /= length;
				self.w /= length;
			}
			let self4 = self1;
			self4.x *= max;
			self4.y *= max;
			self4.z *= max;
			self4.w *= max;
		}
		return self;
	}
	static get_length(this1) {
		let self = this1;
		return Math.sqrt(self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w);
	}
	static get_lengthSq(this1) {
		let self = this1;
		return self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w;
	}
	static get_zero() {
		return new hxmath_math_Vector4Default(0.0,0.0,0.0,0.0);
	}
	static get_xAxis() {
		return new hxmath_math_Vector4Default(1.0,0.0,0.0,0.0);
	}
	static get_yAxis() {
		return new hxmath_math_Vector4Default(0.0,1.0,0.0,0.0);
	}
	static get_zAxis() {
		return new hxmath_math_Vector4Default(0.0,0.0,1.0,0.0);
	}
	static get_wAxis() {
		return new hxmath_math_Vector4Default(0.0,0.0,0.0,1.0);
	}
}
class js_Boot {
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
}
js_Boot.__name__ = true;
class libmap_Entity {
	constructor() {
		this.spawnType = 0;
		this.center = new hxmath_math_Vector3Default(0.0,0.0,0.0);
		this.brushes = [];
		this.properties = new haxe_ds_StringMap();
	}
}
libmap_Entity.__name__ = true;
class libmap_GeoGenerator {
	constructor(mapData) {
		this.mapData = mapData;
	}
	sortVerticesByWinding(faceCenter,faceBasis,faceNormal,lhs,rhs) {
		let lhs1 = lhs.vertex;
		let rhs1 = rhs.vertex;
		let self = faceBasis;
		let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
		let self2 = self1;
		let length = Math.sqrt(self2.x * self2.x + self2.y * self2.y + self2.z * self2.z);
		if(length > 0.0) {
			let self = self1;
			self.x /= length;
			self.y /= length;
			self.z /= length;
		}
		let u = self1;
		let self3 = u;
		let self4 = new hxmath_math_Vector3Default(self3.x,self3.y,self3.z);
		let newX = self4.y * faceNormal.z - self4.z * faceNormal.y;
		let newY = self4.z * faceNormal.x - self4.x * faceNormal.z;
		let newZ = self4.x * faceNormal.y - self4.y * faceNormal.x;
		self4.x = newX;
		self4.y = newY;
		self4.z = newZ;
		let self5 = self4;
		let self6 = self5;
		let length1 = Math.sqrt(self6.x * self6.x + self6.y * self6.y + self6.z * self6.z);
		if(length1 > 0.0) {
			let self = self5;
			self.x /= length1;
			self.y /= length1;
			self.z /= length1;
		}
		let v = self5;
		let self7 = lhs1;
		let self8 = new hxmath_math_Vector3Default(self7.x,self7.y,self7.z);
		self8.x -= faceCenter.x;
		self8.y -= faceCenter.y;
		self8.z -= faceCenter.z;
		let localLhs = self8;
		let lhsPU = localLhs.x * u.x + localLhs.y * u.y + localLhs.z * u.z;
		let lhsPV = localLhs.x * v.x + localLhs.y * v.y + localLhs.z * v.z;
		let self9 = rhs1;
		let self10 = new hxmath_math_Vector3Default(self9.x,self9.y,self9.z);
		self10.x -= faceCenter.x;
		self10.y -= faceCenter.y;
		self10.z -= faceCenter.z;
		let localRhs = self10;
		let rhsPU = localRhs.x * u.x + localRhs.y * u.y + localRhs.z * u.z;
		let rhsPV = localRhs.x * v.x + localRhs.y * v.y + localRhs.z * v.z;
		let lhsAngle = Math.atan2(lhsPV,lhsPU);
		let rhsAngle = Math.atan2(rhsPV,rhsPU);
		if(lhsAngle < rhsAngle) {
			return -1;
		} else if(lhsAngle > rhsAngle) {
			return 1;
		}
		return 0;
	}
	run() {
		let _g = 0;
		let _g1 = this.mapData.entities.length;
		while(_g < _g1) {
			let e = _g++;
			let entInst = this.mapData.entities[e];
			let entityGeoInst = [];
			this.mapData.entitiesGeo[e] = entityGeoInst;
			let _g1 = 0;
			let _g2 = entInst.brushes.length;
			while(_g1 < _g2) {
				let b = _g1++;
				let brushInst = entInst.brushes[b];
				let brushGeoInst = [];
				entityGeoInst[b] = brushGeoInst;
				let _g = 0;
				let _g2 = brushInst.faces.length;
				while(_g < _g2) {
					let f = _g++;
					brushGeoInst[f] = { vertices : [], indices : []};
				}
			}
		}
		let _g2 = 0;
		let _g3 = this.mapData.entities.length;
		while(_g2 < _g3) {
			let e = _g2++;
			let entInst = this.mapData.entities[e];
			entInst.center = new hxmath_math_Vector3Default(0.0,0.0,0.0);
			let _g = 0;
			let _g1 = entInst.brushes.length;
			while(_g < _g1) {
				let b = _g++;
				let brushInst = entInst.brushes[b];
				brushInst.center = new hxmath_math_Vector3Default(0.0,0.0,0.0);
				let vertCount = 0;
				this.generateBrushVertices(e,b);
				let brushGeoInst = this.mapData.entitiesGeo[e][b];
				let _g1 = 0;
				let _g2 = brushInst.faces.length;
				while(_g1 < _g2) {
					let f = _g1++;
					let faceGeoInst = brushGeoInst[f];
					let _g = 0;
					let _g2 = faceGeoInst.vertices.length;
					while(_g < _g2) {
						let v = _g++;
						let b = faceGeoInst.vertices[v].vertex;
						let self = brushInst.center;
						let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
						self1.x += b.x;
						self1.y += b.y;
						self1.z += b.z;
						brushInst.center = self1;
						++vertCount;
					}
				}
				if(vertCount > 0) {
					let self = brushInst.center;
					let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
					self1.x /= vertCount;
					self1.y /= vertCount;
					self1.z /= vertCount;
					brushInst.center = self1;
				}
				let b1 = brushInst.center;
				let self = entInst.center;
				let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
				self1.x += b1.x;
				self1.y += b1.y;
				self1.z += b1.z;
				entInst.center = self1;
			}
			if(entInst.brushes.length > 0) {
				let s = entInst.brushes.length;
				let self = entInst.center;
				let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
				self1.x /= s;
				self1.y /= s;
				self1.z /= s;
				entInst.center = self1;
			}
		}
		let _gthis = this;
		let _g4 = 0;
		let _g5 = this.mapData.entities.length;
		while(_g4 < _g5) {
			let e = _g4++;
			let entityInst = this.mapData.entities[e];
			let entityGeoInst = this.mapData.entitiesGeo[e];
			let _g = 0;
			let _g1 = entityInst.brushes.length;
			while(_g < _g1) {
				let b = _g++;
				let brushInst = entityInst.brushes[b];
				let brushGeoInst = entityGeoInst[b];
				let _g1 = 0;
				let _g2 = brushInst.faces.length;
				while(_g1 < _g2) {
					let f = _g1++;
					let faceInst = brushInst.faces[f];
					let faceGeoInst = brushGeoInst[f];
					if(faceGeoInst.vertices.length < 3) {
						continue;
					}
					let b = faceGeoInst.vertices[0].vertex;
					let self = faceGeoInst.vertices[1].vertex;
					let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
					self1.x -= b.x;
					self1.y -= b.y;
					self1.z -= b.z;
					let windFaceBasis = self1;
					let windFaceCenter = new hxmath_math_Vector3Default(0.0,0.0,0.0);
					let windFaceNormal = faceInst.planeNormal;
					let _g = 0;
					let _g2 = faceGeoInst.vertices.length;
					while(_g < _g2) {
						let v = _g++;
						let b = faceGeoInst.vertices[v].vertex;
						let self = windFaceCenter;
						let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
						self1.x += b.x;
						self1.y += b.y;
						self1.z += b.z;
						windFaceCenter = self1;
					}
					let s = faceGeoInst.vertices.length;
					let self2 = windFaceCenter;
					let self3 = new hxmath_math_Vector3Default(self2.x,self2.y,self2.z);
					self3.x /= s;
					self3.y /= s;
					self3.z /= s;
					windFaceCenter = self3;
					faceGeoInst.vertices.sort(function(b,a) {
						return _gthis.sortVerticesByWinding(windFaceCenter,windFaceBasis,windFaceNormal,a,b);
					});
				}
			}
		}
		let _g6 = 0;
		let _g7 = this.mapData.entities.length;
		while(_g6 < _g7) {
			let e = _g6++;
			let entityInst = this.mapData.entities[e];
			let entityGeoInst = this.mapData.entitiesGeo[e];
			let _g = 0;
			let _g1 = entityInst.brushes.length;
			while(_g < _g1) {
				let b = _g++;
				let brushInst = entityInst.brushes[b];
				let brushGeoInst = entityGeoInst[b];
				let _g1 = 0;
				let _g2 = brushInst.faces.length;
				while(_g1 < _g2) {
					let f = _g1++;
					let faceInst = brushInst.faces[f];
					let faceGeoInst = brushGeoInst[f];
					if(faceGeoInst.vertices.length < 3) {
						continue;
					}
					let _g = 0;
					let _g2 = faceGeoInst.vertices.length - 2;
					while(_g < _g2) {
						let i = _g++;
						faceGeoInst.indices.push(0);
						faceGeoInst.indices.push(i + 1);
						faceGeoInst.indices.push(i + 2);
					}
				}
			}
		}
	}
	generateBrushVertices(entityIdx,brushIdx) {
		let entInst = this.mapData.entities[entityIdx];
		let brushInst = entInst.brushes[brushIdx];
		let _g = 0;
		let _g1 = brushInst.faces.length;
		while(_g < _g1) {
			let f0 = _g++;
			let _g1 = 0;
			let _g2 = brushInst.faces.length;
			while(_g1 < _g2) {
				let f1 = _g1++;
				let _g = 0;
				let _g2 = brushInst.faces.length;
				while(_g < _g2) {
					let f2 = _g++;
					let vertex = this.intersectFaces(brushInst.faces[f0],brushInst.faces[f1],brushInst.faces[f2]);
					if(vertex != null) {
						if(this.vertexInHull(brushInst.faces,vertex)) {
							let faceInst = brushInst.faces[f0];
							let faceGeoInst = this.mapData.entitiesGeo[entityIdx][brushIdx][f0];
							let normal;
							let phongPoroperty = entInst.properties.h["_phong"];
							let phong = phongPoroperty != null && phongPoroperty == "1";
							if(phong) {
								let phongAngleProperty = entInst.properties.h["_phong_angle"];
								if(phongAngleProperty != null) {
									let threshold = Math.cos((parseFloat(phongAngleProperty) + 0.01) * 0.0174533);
									normal = brushInst.faces[f0].planeNormal;
									let a = brushInst.faces[f0].planeNormal;
									let b = brushInst.faces[f1].planeNormal;
									if(a.x * b.x + a.y * b.y + a.z * b.z > threshold) {
										let b = brushInst.faces[f1].planeNormal;
										let self = normal;
										let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
										self1.x += b.x;
										self1.y += b.y;
										self1.z += b.z;
										normal = self1;
									}
									let a1 = brushInst.faces[f0].planeNormal;
									let b1 = brushInst.faces[f2].planeNormal;
									if(a1.x * b1.x + a1.y * b1.y + a1.z * b1.z > threshold) {
										let b = brushInst.faces[f2].planeNormal;
										let self = normal;
										let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
										self1.x += b.x;
										self1.y += b.y;
										self1.z += b.z;
										normal = self1;
									}
									let self = normal;
									let self1 = self;
									let length = Math.sqrt(self1.x * self1.x + self1.y * self1.y + self1.z * self1.z);
									if(length > 0.0) {
										let self1 = self;
										self1.x /= length;
										self1.y /= length;
										self1.z /= length;
									}
								} else {
									let b = brushInst.faces[f1].planeNormal;
									let self = brushInst.faces[f0].planeNormal;
									let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
									self1.x += b.x;
									self1.y += b.y;
									self1.z += b.z;
									let b1 = brushInst.faces[f2].planeNormal;
									let self2 = self1;
									let self3 = new hxmath_math_Vector3Default(self2.x,self2.y,self2.z);
									self3.x += b1.x;
									self3.y += b1.y;
									self3.z += b1.z;
									normal = self3;
									let self4 = normal;
									let self5 = self4;
									let length = Math.sqrt(self5.x * self5.x + self5.y * self5.y + self5.z * self5.z);
									if(length > 0.0) {
										let self = self4;
										self.x /= length;
										self.y /= length;
										self.z /= length;
									}
								}
							} else {
								normal = faceInst.planeNormal;
							}
							let texture = this.mapData.textures[faceInst.textureIdx];
							let uv;
							let tangent;
							if(faceInst.isValveUV) {
								uv = this.getValveUV(vertex,faceInst,texture.width,texture.height);
								tangent = this.getValveTangent(faceInst);
							} else {
								uv = this.getStandardUV(vertex,faceInst,texture.width,texture.height);
								tangent = this.getStandardTangent(faceInst);
							}
							let uniqueVertex = true;
							let duplicateIndex = -1;
							let _g = 0;
							let _g1 = faceGeoInst.vertices.length;
							while(_g < _g1) {
								let v = _g++;
								let compVertex = faceGeoInst.vertices[v].vertex;
								let self = vertex;
								let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
								self1.x -= compVertex.x;
								self1.y -= compVertex.y;
								self1.z -= compVertex.z;
								let self2 = self1;
								if(Math.sqrt(self2.x * self2.x + self2.y * self2.y + self2.z * self2.z) < 1e-10) {
									uniqueVertex = false;
									duplicateIndex = v;
									break;
								}
							}
							if(uniqueVertex) {
								faceGeoInst.vertices.push({ vertex : vertex, normal : normal, uv : uv, tangent : tangent});
							} else if(phong) {
								let fh = faceGeoInst.vertices[duplicateIndex];
								let self = fh.normal;
								let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
								self1.x += normal.x;
								self1.y += normal.y;
								self1.z += normal.z;
								fh.normal = self1;
							}
						}
					}
				}
			}
		}
		let _g2 = 0;
		let _g3 = brushInst.faces.length;
		while(_g2 < _g3) {
			let f = _g2++;
			let faceGeoInst = this.mapData.entitiesGeo[entityIdx][brushIdx][f];
			let _g = 0;
			let _g1 = faceGeoInst.vertices;
			while(_g < _g1.length) {
				let vert = _g1[_g];
				++_g;
				let self = vert.normal;
				let self1 = self;
				let length = Math.sqrt(self1.x * self1.x + self1.y * self1.y + self1.z * self1.z);
				if(length > 0.0) {
					let self1 = self;
					self1.x /= length;
					self1.y /= length;
					self1.z /= length;
				}
			}
		}
	}
	intersectFaces(f0,f1,f2) {
		let b = f1.planeNormal;
		let self = f0.planeNormal;
		let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
		let newX = self1.y * b.z - self1.z * b.y;
		let newY = self1.z * b.x - self1.x * b.z;
		let newZ = self1.x * b.y - self1.y * b.x;
		self1.x = newX;
		self1.y = newY;
		self1.z = newZ;
		let a = self1;
		let b1 = f2.planeNormal;
		let denom = a.x * b1.x + a.y * b1.y + a.z * b1.z;
		if(denom < 1e-10) {
			return null;
		}
		let b2 = f2.planeNormal;
		let self2 = f1.planeNormal;
		let self3 = new hxmath_math_Vector3Default(self2.x,self2.y,self2.z);
		let newX1 = self3.y * b2.z - self3.z * b2.y;
		let newY1 = self3.z * b2.x - self3.x * b2.z;
		let newZ1 = self3.x * b2.y - self3.y * b2.x;
		self3.x = newX1;
		self3.y = newY1;
		self3.z = newZ1;
		let s = f0.planeDist;
		let self4 = self3;
		let self5 = new hxmath_math_Vector3Default(self4.x,self4.y,self4.z);
		self5.x *= s;
		self5.y *= s;
		self5.z *= s;
		let b3 = f0.planeNormal;
		let self6 = f2.planeNormal;
		let self7 = new hxmath_math_Vector3Default(self6.x,self6.y,self6.z);
		let newX2 = self7.y * b3.z - self7.z * b3.y;
		let newY2 = self7.z * b3.x - self7.x * b3.z;
		let newZ2 = self7.x * b3.y - self7.y * b3.x;
		self7.x = newX2;
		self7.y = newY2;
		self7.z = newZ2;
		let s1 = f1.planeDist;
		let self8 = self7;
		let self9 = new hxmath_math_Vector3Default(self8.x,self8.y,self8.z);
		self9.x *= s1;
		self9.y *= s1;
		self9.z *= s1;
		let b4 = self9;
		let self10 = self5;
		let self11 = new hxmath_math_Vector3Default(self10.x,self10.y,self10.z);
		self11.x += b4.x;
		self11.y += b4.y;
		self11.z += b4.z;
		let b5 = f1.planeNormal;
		let self12 = f0.planeNormal;
		let self13 = new hxmath_math_Vector3Default(self12.x,self12.y,self12.z);
		let newX3 = self13.y * b5.z - self13.z * b5.y;
		let newY3 = self13.z * b5.x - self13.x * b5.z;
		let newZ3 = self13.x * b5.y - self13.y * b5.x;
		self13.x = newX3;
		self13.y = newY3;
		self13.z = newZ3;
		let s2 = f2.planeDist;
		let self14 = self13;
		let self15 = new hxmath_math_Vector3Default(self14.x,self14.y,self14.z);
		self15.x *= s2;
		self15.y *= s2;
		self15.z *= s2;
		let b6 = self15;
		let self16 = self11;
		let self17 = new hxmath_math_Vector3Default(self16.x,self16.y,self16.z);
		self17.x += b6.x;
		self17.y += b6.y;
		self17.z += b6.z;
		let self18 = self17;
		let self19 = new hxmath_math_Vector3Default(self18.x,self18.y,self18.z);
		self19.x /= denom;
		self19.y /= denom;
		self19.z /= denom;
		return self19;
	}
	vertexInHull(faces,vertex) {
		let _g = 0;
		while(_g < faces.length) {
			let face = faces[_g];
			++_g;
			let a = face.planeNormal;
			let proj = a.x * vertex.x + a.y * vertex.y + a.z * vertex.z;
			if(proj > face.planeDist && Math.abs(face.planeDist - proj) > 1e-10) {
				return false;
			}
		}
		return true;
	}
	getStandardUV(vertex,face,textureWidth,textureHeight) {
		let a = face.planeNormal;
		let b = new hxmath_math_Vector3Default(0.0,0.0,1.0);
		let du = Math.abs(a.x * b.x + a.y * b.y + a.z * b.z);
		let a1 = face.planeNormal;
		let b1 = new hxmath_math_Vector3Default(0.0,1.0,0.0);
		let dr = Math.abs(a1.x * b1.x + a1.y * b1.y + a1.z * b1.z);
		let a2 = face.planeNormal;
		let b2 = new hxmath_math_Vector3Default(1.0,0.0,0.0);
		let df = Math.abs(a2.x * b2.x + a2.y * b2.y + a2.z * b2.z);
		let uvOut = { u : 0, v : 0};
		if(du >= dr && du >= df) {
			uvOut = { u : vertex.x, v : -vertex.y};
		} else if(dr >= du && dr >= df) {
			uvOut = { u : vertex.x, v : -vertex.z};
		} else if(df >= du && df >= dr) {
			uvOut = { u : vertex.y, v : -vertex.z};
		}
		let angle = face.uvExtra.rot * Math.PI / 180.;
		let rotated = { u : uvOut.u * Math.cos(angle) - uvOut.v * Math.sin(angle), v : uvOut.u * Math.sin(angle) + uvOut.v * Math.cos(angle)};
		uvOut = rotated;
		uvOut.u /= textureWidth;
		uvOut.v /= textureHeight;
		uvOut.u /= face.uvExtra.scaleX;
		uvOut.v /= face.uvExtra.scaleY;
		uvOut.u += face.uvStandard.u / textureWidth;
		uvOut.v += face.uvStandard.v / textureHeight;
		return uvOut;
	}
	getValveUV(vertex,face,textureWidth,textureHeight) {
		let a = face.uvValve.u.axis;
		let a1 = face.uvValve.v.axis;
		let uvOut = { u : a.x * vertex.x + a.y * vertex.y + a.z * vertex.z, v : a1.x * vertex.x + a1.y * vertex.y + a1.z * vertex.z};
		uvOut.u /= textureWidth;
		uvOut.v /= textureHeight;
		uvOut.u /= face.uvExtra.scaleX;
		uvOut.u /= face.uvExtra.scaleY;
		uvOut.u += face.uvValve.u.offset / textureWidth;
		uvOut.v += face.uvValve.v.offset / textureHeight;
		return uvOut;
	}
	rotationMatrix(axis,angle) {
		let cos = Math.cos(angle);
		let sin = Math.sin(angle);
		let cos1 = 1 - cos;
		let x = -axis.x;
		let y = -axis.y;
		let z = -axis.z;
		let xx = x * x;
		let yy = y * y;
		let zz = z * z;
		let len = 1. / Math.sqrt(xx + yy + zz);
		x *= len;
		y *= len;
		z *= len;
		let xcos1 = x * cos1;
		let zcos1 = z * cos1;
		return new hxmath_math_Matrix3x3Default(cos + x * xcos1,y * xcos1 - z * sin,x * zcos1 + y * sin,y * xcos1 + z * sin,cos + y * y * cos1,y * zcos1 - x * sin,x * zcos1 - y * sin,y * zcos1 + x * sin,cos + z * zcos1);
	}
	sign(v) {
		if(v > 0) {
			return 1;
		} else if(v < 0) {
			return -1;
		} else {
			return 0;
		}
	}
	getStandardTangent(face) {
		let a = face.planeNormal;
		let b = new hxmath_math_Vector3Default(0.0,0.0,1.0);
		let du = Math.abs(a.x * b.x + a.y * b.y + a.z * b.z);
		let a1 = face.planeNormal;
		let b1 = new hxmath_math_Vector3Default(0.0,1.0,0.0);
		let dr = Math.abs(a1.x * b1.x + a1.y * b1.y + a1.z * b1.z);
		let a2 = face.planeNormal;
		let b2 = new hxmath_math_Vector3Default(1.0,0.0,0.0);
		let df = Math.abs(a2.x * b2.x + a2.y * b2.y + a2.z * b2.z);
		let dua = Math.abs(du);
		let dra = Math.abs(dr);
		let dfa = Math.abs(df);
		let uAxis = new hxmath_math_Vector3Default(0.0,0.0,0.0);
		let vSign = 0.;
		if(dua >= dra && dua >= dfa) {
			uAxis = new hxmath_math_Vector3Default(1.0,0.0,0.0);
			vSign = du > 0 ? 1 : du < 0 ? -1 : 0;
		} else if(dra >= dua && dra >= dfa) {
			uAxis = new hxmath_math_Vector3Default(1.0,0.0,0.0);
			vSign = -(dr > 0 ? 1 : dr < 0 ? -1 : 0);
		} else if(dfa >= dua && dfa >= dra) {
			uAxis = new hxmath_math_Vector3Default(0.0,1.0,0.0);
			vSign = df > 0 ? 1 : df < 0 ? -1 : 0;
		}
		let v = face.uvExtra.scaleY;
		vSign *= v > 0 ? 1 : v < 0 ? -1 : 0;
		let a3 = this.rotationMatrix(face.planeNormal,-face.uvExtra.rot * Math.PI / 180.0 * vSign);
		uAxis = new hxmath_math_Vector3Default(a3.m00 * uAxis.x + a3.m10 * uAxis.y + a3.m20 * uAxis.z,a3.m01 * uAxis.x + a3.m11 * uAxis.y + a3.m21 * uAxis.z,a3.m02 * uAxis.x + a3.m12 * uAxis.y + a3.m22 * uAxis.z);
		return new hxmath_math_Vector4Default(uAxis.x,uAxis.y,uAxis.z,vSign);
	}
	getValveTangent(face) {
		let self = face.uvValve.u.axis;
		let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
		let self2 = self1;
		let length = Math.sqrt(self2.x * self2.x + self2.y * self2.y + self2.z * self2.z);
		if(length > 0.0) {
			let self = self1;
			self.x /= length;
			self.y /= length;
			self.z /= length;
		}
		let uAxis = self1;
		let self3 = face.uvValve.v.axis;
		let self4 = new hxmath_math_Vector3Default(self3.x,self3.y,self3.z);
		let self5 = self4;
		let length1 = Math.sqrt(self5.x * self5.x + self5.y * self5.y + self5.z * self5.z);
		if(length1 > 0.0) {
			let self = self4;
			self.x /= length1;
			self.y /= length1;
			self.z /= length1;
		}
		let vAxis = self4;
		let self6 = face.planeNormal;
		let self7 = new hxmath_math_Vector3Default(self6.x,self6.y,self6.z);
		let newX = self7.y * uAxis.z - self7.z * uAxis.y;
		let newY = self7.z * uAxis.x - self7.x * uAxis.z;
		let newZ = self7.x * uAxis.y - self7.y * uAxis.x;
		self7.x = newX;
		self7.y = newY;
		self7.z = newZ;
		let a = self7;
		let v = a.x * vAxis.x + a.y * vAxis.y + a.z * vAxis.z;
		let vSign = -(v > 0 ? 1 : v < 0 ? -1 : 0);
		return new hxmath_math_Vector4Default(uAxis.x,uAxis.y,uAxis.z,vSign);
	}
	getBrushVertexCount(entityIdx,brushIdx) {
		let vertexCount = 0;
		let _g = 0;
		let _g1 = this.mapData.entities[entityIdx].brushes[brushIdx].faces.length;
		while(_g < _g1) {
			let i = _g++;
			vertexCount += this.mapData.entitiesGeo[entityIdx][brushIdx][i].vertices.length;
		}
		return vertexCount;
	}
	getBrushIndexCount(entityIdx,brushIdx) {
		let indexCount = 0;
		let _g = 0;
		let _g1 = this.mapData.entities[entityIdx].brushes[brushIdx].faces.length;
		while(_g < _g1) {
			let i = _g++;
			indexCount += this.mapData.entitiesGeo[entityIdx][brushIdx][i].indices.length;
		}
		return indexCount;
	}
}
libmap_GeoGenerator.__name__ = true;
class libmap_MapData {
	constructor() {
		this.worldspawnLayers = [];
		this.textures = [];
		this.entitiesGeo = [];
		this.entities = [];
	}
	registerWorldspawnLayer(name,buildVisuals) {
		this.worldspawnLayers.push({ textureIdx : this.findTexture(name), buildVisuals : buildVisuals});
	}
	findWorldspawnLayer(textureIdx) {
		let _g = 0;
		let _g1 = this.worldspawnLayers.length;
		while(_g < _g1) {
			let i = _g++;
			if(this.worldspawnLayers[i].textureIdx == textureIdx) {
				return i;
			}
		}
		return -1;
	}
	setTextureSize(name,width,height) {
		let _g = 0;
		let _g1 = this.textures;
		while(_g < _g1.length) {
			let t = _g1[_g];
			++_g;
			if(t.name == name) {
				t.width = width;
				t.height = height;
				return;
			}
		}
	}
	setSpawnTypeByClassname(key,spawnType) {
		let _g = 0;
		let _g1 = this.entities;
		while(_g < _g1.length) {
			let e = _g1[_g];
			++_g;
			if(Object.prototype.hasOwnProperty.call(e.properties.h,"classname")) {
				e.spawnType = spawnType;
			}
		}
	}
	registerTexture(name) {
		let _g = 0;
		let _g1 = this.textures.length;
		while(_g < _g1) {
			let i = _g++;
			if(this.textures[i].name == name) {
				return i;
			}
		}
		let tex = { name : name, width : 0, height : 0};
		return this.textures.push(tex) - 1;
	}
	findTexture(textureName) {
		let _g = 0;
		let _g1 = this.textures.length;
		while(_g < _g1) {
			let i = _g++;
			if(this.textures[i].name == textureName) {
				return i;
			}
		}
		return -1;
	}
}
libmap_MapData.__name__ = true;
class libmap_MapParser {
	constructor(input) {
		this.valveUVs = false;
		this.componentIdx = 0;
		this.faceIdx = -1;
		this.brushIdx = -1;
		this.entityIdx = -1;
		this.comment = false;
		this.scope = 0;
		this.input = input;
	}
	parse() {
		this.resetCurrentFace();
		this.resetCurrentBrush();
		this.resetCurrentEntity();
		this.mapData = new libmap_MapData();
		let buf = new StringBuf();
		try {
			while(true) {
				let c = this.input.readByte();
				if(c == 10) {
					this.token(buf.b);
					buf = new StringBuf();
					this.newline();
				} else if(c > 8 && c < 14 || c == 32) {
					this.token(buf.b);
					buf = new StringBuf();
				} else {
					buf.b += String.fromCodePoint(c);
				}
			}
		} catch( _g ) {
			if(!((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				throw _g;
			}
		}
		return this.mapData;
	}
	token(buf) {
		if(this.comment) {
			return;
		}
		if(buf.charAt(0) == "/" && buf.charAt(1) == "/") {
			this.comment = true;
			return;
		}
		switch(this.scope) {
		case 0:
			if(buf.charAt(0) == "{") {
				this.entityIdx++;
				this.brushIdx = -1;
				this.scope = 2;
			}
			break;
		case 2:
			if(buf.charAt(0) == "\"") {
				this.currentPropertyKey = buf.substring(1,buf.length - 1);
				if(buf.charAt(buf.length - 1) == "\"") {
					this.scope = 3;
				}
			} else if(buf.charAt(0) == "{") {
				this.brushIdx++;
				this.faceIdx = -1;
				this.scope = 4;
			} else if(buf.charAt(0) == "}") {
				this.commitEntity();
				this.scope = 0;
			}
			break;
		case 3:
			let isFirst = buf.charAt(0) == "\"";
			let isLast = buf.charAt(buf.length - 1) == "\"";
			let end = isLast ? buf.length - 1 : buf.length;
			if(isFirst) {
				this.currentPropertyValue = buf.substring(1,end);
			} else {
				this.currentPropertyValue += " " + buf.substring(0,end);
			}
			if(isLast) {
				let v = this.currentPropertyValue;
				this.currentEntity.properties.h[this.currentPropertyKey] = v;
				this.scope = 2;
			}
			break;
		case 4:
			if(buf.charAt(0) == "(") {
				this.faceIdx++;
				this.componentIdx = 0;
				this.scope = 5;
			} else if(buf.charAt(0) == "}") {
				this.commitBrush();
				this.scope = 2;
			}
			break;
		case 5:
			if(buf.charAt(0) == ")") {
				this.componentIdx = 0;
				this.scope = 6;
			} else {
				switch(this.componentIdx) {
				case 0:
					this.currentFace.planePoints.v0.x = parseFloat(buf);
					break;
				case 1:
					this.currentFace.planePoints.v0.y = parseFloat(buf);
					break;
				case 2:
					this.currentFace.planePoints.v0.z = parseFloat(buf);
					break;
				default:
				}
				this.componentIdx++;
			}
			break;
		case 6:
			if(buf.charAt(0) == "(") {
				return;
			} else if(buf.charAt(0) == ")") {
				this.componentIdx = 0;
				this.scope = 7;
			} else {
				switch(this.componentIdx) {
				case 0:
					this.currentFace.planePoints.v1.x = parseFloat(buf);
					break;
				case 1:
					this.currentFace.planePoints.v1.y = parseFloat(buf);
					break;
				case 2:
					this.currentFace.planePoints.v1.z = parseFloat(buf);
					break;
				default:
				}
				this.componentIdx++;
			}
			break;
		case 7:
			if(buf.charAt(0) == "(") {
				return;
			} else if(buf.charAt(0) == ")") {
				this.scope = 8;
			} else {
				switch(this.componentIdx) {
				case 0:
					this.currentFace.planePoints.v2.x = parseFloat(buf);
					break;
				case 1:
					this.currentFace.planePoints.v2.y = parseFloat(buf);
					break;
				case 2:
					this.currentFace.planePoints.v2.z = parseFloat(buf);
					break;
				default:
				}
				this.componentIdx++;
			}
			break;
		case 8:
			this.currentFace.textureIdx = this.mapData.registerTexture(buf);
			this.scope = 9;
			break;
		case 9:
			if(buf.charAt(0) == "[") {
				this.valveUVs = true;
				this.componentIdx = 0;
				this.scope = 11;
			} else {
				this.valveUVs = false;
				this.currentFace.uvStandard.u = parseFloat(buf);
				this.scope = 10;
			}
			break;
		case 10:
			this.currentFace.uvStandard.v = parseFloat(buf);
			this.scope = 13;
			break;
		case 11:
			if(buf.charAt(0) == "]") {
				this.componentIdx = 0;
				this.scope = 12;
			} else {
				switch(this.componentIdx) {
				case 0:
					this.currentFace.uvValve.u.axis.x = parseFloat(buf);
					break;
				case 1:
					this.currentFace.uvValve.u.axis.y = parseFloat(buf);
					break;
				case 2:
					this.currentFace.uvValve.u.axis.z = parseFloat(buf);
					break;
				case 3:
					this.currentFace.uvValve.u.offset = parseFloat(buf);
					break;
				default:
				}
				this.componentIdx++;
			}
			break;
		case 12:
			if(buf.charAt(0) == "[") {
				return;
			} else if(buf.charAt(0) == "]") {
				this.scope = 13;
			} else {
				switch(this.componentIdx) {
				case 0:
					this.currentFace.uvValve.v.axis.x = parseFloat(buf);
					break;
				case 1:
					this.currentFace.uvValve.v.axis.y = parseFloat(buf);
					break;
				case 2:
					this.currentFace.uvValve.v.axis.z = parseFloat(buf);
					break;
				case 3:
					this.currentFace.uvValve.v.offset = parseFloat(buf);
					break;
				default:
				}
				this.componentIdx++;
			}
			break;
		case 13:
			this.currentFace.uvExtra.rot = parseFloat(buf);
			this.scope = 14;
			break;
		case 14:
			this.currentFace.uvExtra.scaleX = parseFloat(buf);
			this.scope = 15;
			break;
		case 15:
			this.currentFace.uvExtra.scaleY = parseFloat(buf);
			this.commitFace();
			this.scope = 4;
			break;
		default:
		}
	}
	newline() {
		this.comment = false;
	}
	commitFace() {
		let b = this.currentFace.planePoints.v0;
		let self = this.currentFace.planePoints.v1;
		let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
		self1.x -= b.x;
		self1.y -= b.y;
		self1.z -= b.z;
		let v0v1 = self1;
		let b1 = this.currentFace.planePoints.v1;
		let self2 = this.currentFace.planePoints.v2;
		let self3 = new hxmath_math_Vector3Default(self2.x,self2.y,self2.z);
		self3.x -= b1.x;
		self3.y -= b1.y;
		self3.z -= b1.z;
		let v1v2 = self3;
		let self4 = v1v2;
		let newX = self4.y * v0v1.z - self4.z * v0v1.y;
		let newY = self4.z * v0v1.x - self4.x * v0v1.z;
		let newZ = self4.x * v0v1.y - self4.y * v0v1.x;
		self4.x = newX;
		self4.y = newY;
		self4.z = newZ;
		let self5 = self4;
		let self6 = self5;
		let length = Math.sqrt(self6.x * self6.x + self6.y * self6.y + self6.z * self6.z);
		if(length > 0.0) {
			let self = self5;
			self.x /= length;
			self.y /= length;
			self.z /= length;
		}
		this.currentFace.planeNormal = self5;
		let a = this.currentFace.planeNormal;
		let b2 = this.currentFace.planePoints.v0;
		this.currentFace.planeDist = a.x * b2.x + a.y * b2.y + a.z * b2.z;
		this.currentFace.isValveUV = this.valveUVs;
		this.currentBrush.faces.push(this.currentFace);
		this.resetCurrentFace();
	}
	commitBrush() {
		this.currentEntity.brushes.push(this.currentBrush);
		this.resetCurrentBrush();
	}
	commitEntity() {
		this.mapData.entities.push(this.currentEntity);
		this.resetCurrentEntity();
	}
	resetCurrentFace() {
		let this1 = new hxmath_math_Vector3Default(0.0,0.0,0.0);
		let this2 = new hxmath_math_Vector3Default(0.0,0.0,0.0);
		let this3 = new hxmath_math_Vector3Default(0.0,0.0,0.0);
		let this4 = new hxmath_math_Vector3Default(0.0,0.0,0.0);
		let this5 = new hxmath_math_Vector3Default(0.0,0.0,0.0);
		let this6 = new hxmath_math_Vector3Default(0.0,0.0,0.0);
		this.currentFace = { planePoints : { v0 : this1, v1 : this2, v2 : this3}, planeNormal : this4, planeDist : 0, textureIdx : 0, isValveUV : false, uvStandard : { u : 0, v : 0}, uvValve : { u : { axis : this5, offset : 0}, v : { axis : this6, offset : 0}}, uvExtra : { rot : 0, scaleX : 0, scaleY : 0}};
	}
	resetCurrentBrush() {
		this.currentBrush = { faces : [], center : new hxmath_math_Vector3Default(0.0,0.0,0.0)};
	}
	resetCurrentEntity() {
		this.currentEntity = new libmap_Entity();
	}
}
libmap_MapParser.__name__ = true;
class libmap_SurfaceGatherer {
	constructor(mapData) {
		this.filterWorldspawnLayers = true;
		this.faceFilterTextureIdx = -1;
		this.brushFilterTextureIdx = -1;
		this.textureFilterIdx = -1;
		this.entityFilterIdx = -1;
		this.splitType = 0;
		this.mapData = mapData;
	}
	setBrushFilterTexture(name) {
		this.brushFilterTextureIdx = this.mapData.findTexture(name);
	}
	setFaceFilterTexture(name) {
		this.faceFilterTextureIdx = this.mapData.findTexture(name);
	}
	setTextureFilter(name) {
		this.textureFilterIdx = this.mapData.findTexture(name);
	}
	run() {
		this.outSurfaces = [];
		let indexOffset = 0;
		let surfInst = null;
		if(this.splitType == 0) {
			surfInst = this.addSurface();
		}
		let _g = 0;
		let _g1 = this.mapData.entities.length;
		while(_g < _g1) {
			let e = _g++;
			if(this.filterEntity(e)) {
				continue;
			}
			let entityInst = this.mapData.entities[e];
			if(this.splitType == 1) {
				if(entityInst.spawnType == 1) {
					this.addSurface();
					surfInst = this.outSurfaces[0];
					indexOffset = surfInst.vertices.length;
				} else {
					surfInst = this.addSurface();
					indexOffset = surfInst.vertices.length;
				}
			}
			let _g1 = 0;
			let _g2 = entityInst.brushes.length;
			while(_g1 < _g2) {
				let b = _g1++;
				if(this.filterBrush(e,b)) {
					continue;
				}
				if(this.splitType == 2) {
					indexOffset = 0;
					surfInst = this.addSurface();
				}
				let brushInst = entityInst.brushes[b];
				let _g = 0;
				let _g2 = brushInst.faces.length;
				while(_g < _g2) {
					let f = _g++;
					if(this.filterFace(e,b,f)) {
						continue;
					}
					let faceGeoInst = this.mapData.entitiesGeo[e][b][f];
					let _g1 = 0;
					let _g2 = faceGeoInst.vertices;
					while(_g1 < _g2.length) {
						let vertex = _g2[_g1];
						++_g1;
						if(entityInst.spawnType == 2 || entityInst.spawnType == 3) {
							let b = entityInst.center;
							let self = vertex.vertex;
							let self1 = new hxmath_math_Vector3Default(self.x,self.y,self.z);
							self1.x -= b.x;
							self1.y -= b.y;
							self1.z -= b.z;
							vertex.vertex = self1;
						}
						surfInst.vertices.push(vertex);
					}
					let _g3 = 0;
					let _g4 = (faceGeoInst.vertices.length - 2) * 3;
					while(_g3 < _g4) {
						let i = _g3++;
						surfInst.indices.push(faceGeoInst.indices[i] + indexOffset);
					}
					indexOffset += faceGeoInst.vertices.length;
				}
			}
		}
	}
	filterEntity(entityIdx) {
		if(this.entityFilterIdx != -1) {
			return entityIdx != this.entityFilterIdx;
		} else {
			return false;
		}
	}
	filterBrush(entityIdx,brushIdx) {
		let faces = this.mapData.entities[entityIdx].brushes[brushIdx].faces;
		if(this.brushFilterTextureIdx != -1) {
			let fullyTextured = true;
			let _g = 0;
			while(_g < faces.length) {
				let f = faces[_g];
				++_g;
				if(f.textureIdx != this.brushFilterTextureIdx) {
					fullyTextured = false;
					break;
				}
			}
			if(fullyTextured) {
				return true;
			}
		}
		let _g = 0;
		while(_g < faces.length) {
			let f = faces[_g];
			++_g;
			let _g1 = 0;
			let _g2 = this.mapData.worldspawnLayers;
			while(_g1 < _g2.length) {
				let l = _g2[_g1];
				++_g1;
				haxe_Log.trace(f,{ fileName : "libmap/SurfaceGatherer.hx", lineNumber : 120, className : "libmap.SurfaceGatherer", methodName : "filterBrush", customParams : [l]});
				if(f.textureIdx == l.textureIdx) {
					return this.filterWorldspawnLayers;
				}
			}
		}
		return false;
	}
	filterFace(entityIdx,brushIdx,faceIdx) {
		let faceInst = this.mapData.entities[entityIdx].brushes[brushIdx].faces[faceIdx];
		let faceGeoInst = this.mapData.entitiesGeo[entityIdx][brushIdx][faceIdx];
		if(faceGeoInst.vertices.length < 3) {
			return true;
		}
		if(this.faceFilterTextureIdx != -1 && faceInst.textureIdx == this.faceFilterTextureIdx) {
			return true;
		}
		if(this.textureFilterIdx != -1 && faceInst.textureIdx != this.textureFilterIdx) {
			return true;
		}
		return false;
	}
	addSurface() {
		let s = { vertices : [], indices : []};
		this.outSurfaces.push(s);
		return s;
	}
	resetState() {
		this.outSurfaces = [];
	}
	resetParams() {
		this.splitType = 0;
		this.entityFilterIdx = -1;
		this.textureFilterIdx = -1;
		this.brushFilterTextureIdx = -1;
		this.faceFilterTextureIdx = -1;
		this.filterWorldspawnLayers = true;
	}
}
libmap_SurfaceGatherer.__name__ = true;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
{
	String.__name__ = true;
	Array.__name__ = true;
}
js_Boot.__toStr = ({ }).toString;
hxmath_math_IntVector2.elementCount = 2;
hxmath_math_MathUtil.eps = 1e-6;
hxmath_math_Matrix2x2.elementCount = 4;
hxmath_math_Matrix3x2.elementCount = 6;
hxmath_math_Matrix3x3.elementCount = 9;
hxmath_math_Matrix4x4.elementCount = 16;
hxmath_math_Quaternion.elementCount = 4;
hxmath_math_Vector2.elementCount = 2;
hxmath_math_Vector3.elementCount = 3;
hxmath_math_Vector4.elementCount = 4;
libmap_GeoGenerator.EPSILON = 1e-10;


class JsHxInput extends haxe_io_Input {
	constructor(uint8) {
		super();
		this.buffer = uint8;
		this.index = 0;
	}
	readByte() {
		if(this.index >= this.buffer.byteLength) {
			throw new haxe_io_Eof();
		}
		return this.buffer[this.index++];
	}
}

export {
	libmap_GeoGenerator as GeoGenerator,
	libmap_MapParser as MapParser,
	libmap_SurfaceGatherer as SurfaceGatherer,
	JsHxInput as Input
}